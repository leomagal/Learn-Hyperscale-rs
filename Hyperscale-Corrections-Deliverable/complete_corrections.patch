diff --git a/en/flowcharts/images/01_general_architecture_improved.png b/en/flowcharts/images/01_general_architecture_improved.png
new file mode 100644
index 0000000..bfdd5d8
Binary files /dev/null and b/en/flowcharts/images/01_general_architecture_improved.png differ
diff --git a/en/flowcharts/images/02_bft_consensus_cycle_corrected.png b/en/flowcharts/images/02_bft_consensus_cycle_corrected.png
new file mode 100644
index 0000000..c61ace9
Binary files /dev/null and b/en/flowcharts/images/02_bft_consensus_cycle_corrected.png differ
diff --git a/en/flowcharts/images/03_transaction_flow_improved.png b/en/flowcharts/images/03_transaction_flow_improved.png
new file mode 100644
index 0000000..1cf22fe
Binary files /dev/null and b/en/flowcharts/images/03_transaction_flow_improved.png differ
diff --git a/en/flowcharts/images/04_cross_shard_transaction_flow_improved.png b/en/flowcharts/images/04_cross_shard_transaction_flow_improved.png
new file mode 100644
index 0000000..baf7629
Binary files /dev/null and b/en/flowcharts/images/04_cross_shard_transaction_flow_improved.png differ
diff --git a/en/flowcharts/images/04_node_state_machine.png b/en/flowcharts/images/04_node_state_machine.png
new file mode 100644
index 0000000..3a3f9eb
Binary files /dev/null and b/en/flowcharts/images/04_node_state_machine.png differ
diff --git a/en/flowcharts/images/05_voting_qc_cycle_improved.png b/en/flowcharts/images/05_voting_qc_cycle_improved.png
new file mode 100644
index 0000000..067b8e5
Binary files /dev/null and b/en/flowcharts/images/05_voting_qc_cycle_improved.png differ
diff --git a/en/flowcharts/images/06_distributed_execution_improved.png b/en/flowcharts/images/06_distributed_execution_improved.png
new file mode 100644
index 0000000..e67abc2
Binary files /dev/null and b/en/flowcharts/images/06_distributed_execution_improved.png differ
diff --git a/en/flowcharts/images/07_complete_height_cycle_corrected.png b/en/flowcharts/images/07_complete_height_cycle_corrected.png
new file mode 100644
index 0000000..b464b71
Binary files /dev/null and b/en/flowcharts/images/07_complete_height_cycle_corrected.png differ
diff --git a/en/flowcharts/images/08_failure_handling_view_change.html b/en/flowcharts/images/08_failure_handling_view_change.html
new file mode 100644
index 0000000..52c6e52
--- /dev/null
+++ b/en/flowcharts/images/08_failure_handling_view_change.html
@@ -0,0 +1,119 @@
+<!DOCTYPE html>
+<html>
+<head>
+    <meta charset="UTF-8">
+    <title>Mermaid Renderer</title>
+    
+    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
+    <style>
+        body {
+            font-family: "Noto Sans CJK SC", "WenQuanYi Zen Hei", "SimSun", "Microsoft YaHei",
+                         "Arial Unicode MS", "Arial", sans-serif;
+            line-height: 1.6;
+            margin: 0;
+            background: white;
+            color: #333;
+        }
+         
+        .mermaid {
+            text-align: center;
+            margin: 1.5em 0;
+            page-break-inside: avoid;
+            background-color: transparent;
+        }
+        .mermaid svg {
+            max-width: 100%;
+            height: auto;
+        }
+    </style>
+</head>
+<body>
+    <div class="mermaid">graph TD
+    START[&#34;â±ï¸ Round Timeout&lt;br/&gt;Leader Does Not Propose&#34;] --&gt; DETECT[&#34;ğŸš¨ Detect Failure&lt;br/&gt;Waited X seconds&#34;]
+    
+    DETECT --&gt; UNLOCK[&#34;ğŸ”“ Unlock Vote&lt;br/&gt;Remove Vote Lock&#34;]
+    
+    UNLOCK --&gt; INCREASE_VIEW[&#34;ğŸ“ˆ Increment View&lt;br/&gt;View &#43;= 1&lt;br/&gt;Round &#43;= 1&#34;]
+    
+    INCREASE_VIEW --&gt; NEW_LEADER[&#34;ğŸ‘‘ New Leader&lt;br/&gt;Leader = Validator[Round % N]&#34;]
+    
+    NEW_LEADER --&gt; LEADER_CHECK{&#34;New Leader&lt;br/&gt;is Honest?&#34;}
+    
+    LEADER_CHECK --&gt;|No| TIMEOUT_AGAIN[&#34;â±ï¸ Timeout Again&lt;br/&gt;Repeat View Change&#34;]
+    TIMEOUT_AGAIN --&gt; INCREASE_VIEW
+    
+    LEADER_CHECK --&gt;|Yes| PROPOSE_NEW[&#34;ğŸ“ New Leader Proposes&lt;br/&gt;Block with HighQC&#34;]
+    
+    PROPOSE_NEW --&gt; SYNC[&#34;ğŸ”„ Synchronization&lt;br/&gt;Nodes Receive Proposal&#34;]
+    
+    SYNC --&gt; VALIDATE[&#34;âœ… Validate Block&lt;br/&gt;- Valid Parent QC&lt;br/&gt;- Signature OK&#34;]
+    
+    VALIDATE --&gt;|Invalid| REJECT[&#34;âŒ Rejects&lt;br/&gt;New Timeout&#34;]
+    REJECT --&gt; INCREASE_VIEW
+    
+    VALIDATE --&gt;|Valid| VOTE_NEW[&#34;ğŸ—³ï¸ Vote on New Block&#34;]
+    
+    VOTE_NEW --&gt; COLLECT[&#34;ğŸ“Š Collect Votes&lt;br/&gt;2f&#43;1 Required&#34;]
+    
+    COLLECT --&gt; QC_NEW[&#34;ğŸ–ï¸ QC Created&lt;br/&gt;System Recovered&#34;]
+    
+    QC_NEW --&gt; PROGRESS[&#34;âœ… System Progresses&lt;br/&gt;Consensus Restored&#34;]
+    
+    PROGRESS --&gt; END[&#34;ğŸ Back to Normal&#34;]
+    
+    style START fill:#ff6b6b,stroke:#c92a2a,color:#fff
+    style DETECT fill:#ffd43b,stroke:#f59f00,color:#000
+    style UNLOCK fill:#4c6ef5,stroke:#1971c2,color:#fff
+    style NEW_LEADER fill:#51cf66,stroke:#2f9e44,color:#fff
+    style QC_NEW fill:#da77f2,stroke:#9c36b5,color:#fff
+    style PROGRESS fill:#9c36b5,stroke:#6c2a8f,color:#fff
+</div>
+    <script>
+        
+        if (typeof mermaid !== 'undefined') {
+            mermaid.initialize({
+                startOnLoad: false,  
+                theme: 'default',
+                securityLevel: 'loose'
+            });
+        }
+
+        
+        document.addEventListener("DOMContentLoaded", async function() {
+            if (typeof mermaid === 'undefined') {
+                return;
+            }
+
+            const mermaidElements = document.querySelectorAll('.mermaid');
+            let hasError = false;
+
+            for (let i = 0; i < mermaidElements.length; i++) {
+                const element = mermaidElements[i];
+                const mermaidCode = element.textContent.trim();
+
+                try {
+                    const { svg } = await mermaid.render('mermaid-diagram-' + i, mermaidCode);
+                    element.innerHTML = svg;
+                    console.log('Mermaid diagram ' + (i + 1) + ' rendered successfully');
+                } catch (error) {
+                    hasError = true;
+                    console.error('Mermaid rendering error for diagram ' + (i + 1) + ':', error);
+
+                    
+                    element.innerHTML = '<div class="mermaid-error" style="color: red; border: 2px solid red; padding: 10px; border-radius: 5px; background: #ffeeee;">' +
+                        '<strong>Mermaid Rendering Error (Diagram ' + (i + 1) + '):</strong><br>' +
+                        '<code>' + error.message + '</code>' +
+                        '</div>';
+
+                    
+                    document.body.classList.add('mermaid-render-failed');
+                }
+            }
+
+            
+            window.mermaidRenderComplete = true;
+            window.mermaidHasError = hasError;
+        });
+    </script>
+</body>
+</html>
diff --git a/en/flowcharts/images/08_failure_handling_view_change_corrected.png b/en/flowcharts/images/08_failure_handling_view_change_corrected.png
new file mode 100644
index 0000000..8190d8b
Binary files /dev/null and b/en/flowcharts/images/08_failure_handling_view_change_corrected.png differ
diff --git a/en/flowcharts/mermaid/01_general_architecture_improved.mmd b/en/flowcharts/mermaid/01_general_architecture_improved.mmd
new file mode 100644
index 0000000..a80f305
--- /dev/null
+++ b/en/flowcharts/mermaid/01_general_architecture_improved.mmd
@@ -0,0 +1,49 @@
+graph TB
+    subgraph "Network Layer"
+        NET["ğŸŒ P2P Network<br/>Gossip Protocol"]
+    end
+    
+    subgraph "Production Layer"
+        PROD["ğŸ­ Production Runtime<br/>Thread Pool Specialization"]
+    end
+    
+    NET -->|Events| NODE
+    PROD -->|Executes| NODE
+    
+    subgraph "Node Layer"
+        NODE["ğŸ–¥ï¸ NodeStateMachine<br/>Main Orchestrator"]
+    end
+    
+    NODE -->|Coordinates| BFT
+    NODE -->|Coordinates| EXEC
+    NODE -->|Coordinates| MEMPOOL
+    NODE -->|Coordinates| PROV
+    NODE -->|Coordinates| LIVELOCK
+    
+    subgraph "Main Components"
+        BFT["ğŸ”· BFT State Machine<br/>HotStuff-2 Consensus<br/>- Vote Locking<br/>- Unlock Rule<br/>- View Sync"]
+        EXEC["ğŸŸ¢ Execution Engine<br/>Transaction Execution<br/>- Jellyfish Merkle Tree<br/>- State Root"]
+        MEMPOOL["ğŸŸ¡ Mempool<br/>Transaction Pool<br/>- Conflict Detection<br/>- Categorization<br/>- Ready/Deferred"]
+        PROV["ğŸŸ£ Provisioning<br/>Block Preparation<br/>- Collect Txs<br/>- Order Txs"]
+        LIVELOCK["ğŸŸ  Livelock Prevention<br/>Cycle Detection<br/>- Deadlock Detection<br/>- Retry Logic"]
+    end
+    
+    BFT -->|Uses| TYPES
+    EXEC -->|Uses| TYPES
+    MEMPOOL -->|Uses| TYPES
+    
+    subgraph "Data Layer"
+        TYPES["ğŸ“‹ Types & Structures<br/>- Hash<br/>- Block<br/>- Vote<br/>- QC"]
+        CRYPTO["ğŸ” Cryptography<br/>- BLS12-381<br/>- Blake3<br/>- Ed25519"]
+        STORAGE["ğŸ’¾ Storage<br/>- State Root<br/>- Ledger<br/>- Transactions"]
+    end
+    
+    TYPES -->|Validates| CRYPTO
+    CRYPTO -->|Protects| STORAGE
+    
+    style NODE fill:#ff6b6b,stroke:#c92a2a,color:#fff
+    style BFT fill:#4dabf7,stroke:#1971c2,color:#fff
+    style EXEC fill:#51cf66,stroke:#2f9e44,color:#fff
+    style MEMPOOL fill:#ffd43b,stroke:#f59f00,color:#000
+    style PROV fill:#da77f2,stroke:#9c36b5,color:#fff
+    style LIVELOCK fill:#ff8787,stroke:#fa5252,color:#fff
diff --git a/en/flowcharts/mermaid/02_bft_consensus_cycle_corrected.mmd b/en/flowcharts/mermaid/02_bft_consensus_cycle_corrected.mmd
new file mode 100644
index 0000000..841f359
--- /dev/null
+++ b/en/flowcharts/mermaid/02_bft_consensus_cycle_corrected.mmd
@@ -0,0 +1,62 @@
+graph TD
+    A["ğŸš€ Epoch Start<br/>Epoch = N"] --> B["Round = 0"]
+    B --> C["ğŸ‘‘ Leader Election<br/>Leader = Validator[Round % N]"]
+    C --> D["ğŸ”— Leader Proposes Block<br/>Block(Height, Round, Txs)"]
+    D --> E["ğŸ“¥ Nodes Receive Proposal"]
+    E --> F["âœ… Block Validation<br/>- Leader Signature<br/>- Merkle Root<br/>- State Root<br/>- Parent QC"]
+    
+    F -->|Invalid| G["âŒ Reject Block"]
+    G --> H["â±ï¸ Timeout<br/>Waiting for valid block"]
+    
+    F -->|Valid| I["ğŸ”’ Check Vote Lock<br/>voted_heights.contains_key(height)?"]
+    
+    I -->|Already Voted| J["ğŸš« Cannot Vote<br/>Already locked on different block"]
+    J --> H
+    
+    I -->|Not Voted| K["ğŸ—³ï¸ Node Votes on Block<br/>Vote(Block, Validator, Sig)"]
+    K --> L["ğŸ“¢ Broadcast Vote<br/>Send to all"]
+    
+    L --> M["ğŸ“Š Vote Collection<br/>VoteSet accumulates votes"]
+    M --> N{"2f+1 Votes<br/>Received?"}
+    
+    N -->|No| O["â±ï¸ Timeout<br/>Waiting for more votes"]
+    O --> P["ğŸ”„ Skip to Next Round<br/>Round += 1"]
+    P --> C
+    
+    N -->|Yes| Q["âœï¸ Signature Aggregation<br/>BLS12-381 Aggregation"]
+    Q --> R["ğŸ–ï¸ Create Quorum Certificate<br/>QC(Block, Signers, AggSig)"]
+    R --> S["ğŸ“¡ Broadcast QC<br/>Send to all nodes"]
+    
+    S --> T["ğŸ“¥ Nodes Receive QC"]
+    T --> U["ğŸ”„ Sync View<br/>if QC.round > local.view:<br/>  local.view = QC.round"]
+    U --> V["ğŸ”“ Unlock Vote<br/>Remove locks for heights â‰¤ QC.height"]
+    
+    V --> W{"Two-Chain Rule?<br/>QC.parent_qc exists?"}
+    
+    W -->|No| X["â³ Wait for Next QC"]
+    X --> P
+    
+    W -->|Yes| Y["âœ… Block Committed!<br/>Two-chain rule satisfied"]
+    Y --> Z["âš™ï¸ Execute Transactions<br/>Update State Root"]
+    Z --> AA["ğŸ’¾ Finalize Block"]
+    
+    AA --> AB{"Epoch End?<br/>Blocks >= Threshold"}
+    
+    AB -->|No| AC["ğŸ”„ Next Round<br/>Round += 1"]
+    AC --> C
+    
+    AB -->|Yes| AD["ğŸ‰ New Epoch<br/>Epoch += 1<br/>Round = 0"]
+    AD --> A
+    
+    H --> AE["â±ï¸ View Change Timer<br/>Timeout X seconds"]
+    AE --> AF["ğŸ”“ Unlock Vote<br/>Remove all locks"]
+    AF --> AG["â• Increment View<br/>View += 1<br/>Round += 1"]
+    AG --> C
+    
+    style A fill:#ff6b6b,stroke:#c92a2a,color:#fff
+    style Y fill:#51cf66,stroke:#2f9e44,color:#fff
+    style R fill:#4dabf7,stroke:#1971c2,color:#fff
+    style U fill:#ffd43b,stroke:#f59f00,color:#000
+    style V fill:#ffd43b,stroke:#f59f00,color:#000
+    style I fill:#a78bfa,stroke:#7c3aed,color:#fff
+    style J fill:#ff8787,stroke:#fa5252,color:#fff
diff --git a/en/flowcharts/mermaid/03_transaction_flow_improved.mmd b/en/flowcharts/mermaid/03_transaction_flow_improved.mmd
new file mode 100644
index 0000000..f5a1836
--- /dev/null
+++ b/en/flowcharts/mermaid/03_transaction_flow_improved.mmd
@@ -0,0 +1,65 @@
+graph LR
+    subgraph "Phase 1: Reception & Validation"
+        A["ğŸ“¥ Transaction Received<br/>from Client"]
+        B["âœ… Basic Validation<br/>- Signature<br/>- Format<br/>- Nonce"]
+    end
+    
+    subgraph "Phase 2: Mempool Processing"
+        C["ğŸ“Š Dependency Analysis<br/>DependencyGraph"]
+        D{"Conflict<br/>Detected?"}
+        E["ğŸŸ¢ Ready State<br/>No conflicts"]
+        F["ğŸ”´ Deferred State<br/>Waiting for dependency"]
+    end
+    
+    subgraph "Phase 3: Block Inclusion"
+        G["ğŸ“‹ Categorize Transaction<br/>1. Retry (failed before)<br/>2. Priority (CommitmentProof)<br/>3. Normal"]
+        H["ğŸ”— Propose in Block<br/>Order: Retry â†’ Priority â†’ Normal"]
+    end
+    
+    subgraph "Phase 4: Consensus"
+        I["ğŸ—³ï¸ Nodes Vote on Block"]
+        J["ğŸ–ï¸ QC Created<br/>2f+1 Consensus"]
+    end
+    
+    subgraph "Phase 5: Execution"
+        K["âœ… Block Committed<br/>Two-chain rule"]
+        L["âš™ï¸ Execute Transaction<br/>Update State"]
+        M["ğŸŸ¢ Executed State<br/>Success"]
+    end
+    
+    subgraph "Phase 6: Finalization"
+        N["ğŸ’¾ Update Mempool<br/>Remove executed"]
+        O["ğŸ Transaction Complete"]
+    end
+    
+    A --> B
+    B -->|Invalid| P["âŒ Reject<br/>Discard"]
+    P --> O
+    
+    B -->|Valid| C
+    C --> D
+    D -->|No Conflict| E
+    D -->|Conflict| F
+    
+    E --> G
+    F --> Q["â³ Wait for Dependency<br/>Retry later"]
+    Q --> E
+    
+    G --> H
+    H --> I
+    I --> J
+    J --> K
+    K --> L
+    L -->|Success| M
+    L -->|Failure| R["ğŸ”´ Aborted State<br/>Conflict/Error"]
+    R --> N
+    
+    M --> N
+    N --> O
+    
+    style A fill:#ff6b6b,stroke:#c92a2a,color:#fff
+    style E fill:#51cf66,stroke:#2f9e44,color:#fff
+    style F fill:#ffd43b,stroke:#f59f00,color:#000
+    style H fill:#4dabf7,stroke:#1971c2,color:#fff
+    style M fill:#51cf66,stroke:#2f9e44,color:#fff
+    style R fill:#ff8787,stroke:#fa5252,color:#fff
diff --git a/en/flowcharts/mermaid/04_cross_shard_transaction_flow_improved.mmd b/en/flowcharts/mermaid/04_cross_shard_transaction_flow_improved.mmd
new file mode 100644
index 0000000..f58f740
--- /dev/null
+++ b/en/flowcharts/mermaid/04_cross_shard_transaction_flow_improved.mmd
@@ -0,0 +1,50 @@
+graph TD
+    A["ğŸš€ Cross-Shard Transaction<br/>Spans Multiple Shards"] --> B["ğŸ“‹ Identify Shards<br/>Source & Destination"]
+    B --> C["ğŸ”— Shard 1: Source<br/>Prepare Phase"]
+    
+    C --> D["âœ… Validate Transaction<br/>- Signature<br/>- Sufficient Balance"]
+    D -->|Invalid| E["âŒ Reject"]
+    E --> F["ğŸ End"]
+    
+    D -->|Valid| G["âš™ï¸ Execute Source<br/>- Deduct Balance<br/>- Create CommitmentProof"]
+    G --> H["ğŸ“œ CommitmentProof<br/>Cryptographic proof of execution"]
+    
+    H --> I["ğŸ“¤ Send CommitmentProof<br/>to Destination Shard"]
+    I --> J["ğŸ”— Shard 2: Destination<br/>Commit Phase"]
+    
+    J --> K["ğŸ“¥ Receive CommitmentProof"]
+    K --> L["âœ… Verify CommitmentProof<br/>- Signature valid?<br/>- Source executed?"]
+    
+    L -->|Invalid| M["âŒ Reject<br/>Invalid proof"]
+    M --> N["ğŸ”„ Rollback Source<br/>Refund balance"]
+    N --> F
+    
+    L -->|Valid| O["ğŸ“‹ Categorize in Block<br/>Priority Transaction<br/>(has CommitmentProof)"]
+    O --> P["ğŸŸ¢ Ready State<br/>Included in block"]
+    
+    P --> Q["ğŸ—³ï¸ Consensus<br/>Nodes vote on block"]
+    Q --> R["ğŸ–ï¸ QC Created<br/>2f+1 consensus"]
+    
+    R --> S["âœ… Block Committed<br/>Two-chain rule"]
+    S --> T["âš™ï¸ Execute Destination<br/>- Add Balance<br/>- Finalize"]
+    
+    T --> U{"Execution<br/>Success?"}
+    
+    U -->|Yes| V["âœ… Transaction Finalized<br/>Both shards updated"]
+    U -->|No| W["ğŸ”„ Rollback<br/>Revert both shards"]
+    
+    V --> X["ğŸ’¾ Update State Root<br/>Both shards"]
+    W --> X
+    
+    X --> Y["ğŸ“‹ Update Mempool<br/>Remove from pending"]
+    Y --> F
+    
+    style A fill:#ff6b6b,stroke:#c92a2a,color:#fff
+    style C fill:#4dabf7,stroke:#1971c2,color:#fff
+    style J fill:#4dabf7,stroke:#1971c2,color:#fff
+    style G fill:#51cf66,stroke:#2f9e44,color:#fff
+    style H fill:#ffd43b,stroke:#f59f00,color:#000
+    style O fill:#51cf66,stroke:#2f9e44,color:#fff
+    style T fill:#51cf66,stroke:#2f9e44,color:#fff
+    style V fill:#51cf66,stroke:#2f9e44,color:#fff
+    style W fill:#ff8787,stroke:#fa5252,color:#fff
diff --git a/en/flowcharts/mermaid/05_voting_qc_cycle_improved.mmd b/en/flowcharts/mermaid/05_voting_qc_cycle_improved.mmd
new file mode 100644
index 0000000..208190a
--- /dev/null
+++ b/en/flowcharts/mermaid/05_voting_qc_cycle_improved.mmd
@@ -0,0 +1,56 @@
+graph TD
+    A["ğŸ“ Block Proposed<br/>Block(Height, Round, Txs)"] --> B["ğŸ“¥ Node Receives Proposal"]
+    B --> C["âœ… Validate Block<br/>- Leader Signature<br/>- Merkle Root<br/>- State Root<br/>- Parent QC"]
+    
+    C -->|Invalid| D["âŒ Reject<br/>Does not vote"]
+    D --> E["End"]
+    
+    C -->|Valid| F["ğŸ”’ Verify Vote Lock<br/>Check: QC.Round > Locked.Round?"]
+    
+    F -->|No| G["âœ… Lock is Valid<br/>Can vote"]
+    F -->|Yes| H["ğŸ”“ Lock Expired<br/>Can vote"]
+    
+    G --> I["ğŸ—³ï¸ Create Vote<br/>Vote(Block, Validator, Sig)"]
+    H --> I
+    
+    I --> J["ğŸ“¢ Broadcast Vote<br/>Send to all nodes"]
+    J --> K["ğŸ“Š Vote Collection<br/>VoteSet at Leader"]
+    K --> L{"2f+1 Votes<br/>Received?"}
+    
+    L -->|No| M["â³ Wait for More Votes"]
+    M --> N{"Timeout?"}
+    N -->|Yes| O["â±ï¸ Skip to Next Round"]
+    N -->|No| M
+    
+    L -->|Yes| P["âœï¸ Batch Verification<br/>Verify all votes"]
+    P -->|Fail| Q["âŒ Reject Votes<br/>Invalid signatures"]
+    Q --> O
+    
+    P -->|Success| R["ğŸ”— Aggregate Signatures<br/>BLS12-381 Aggregation"]
+    R --> S["ğŸ–ï¸ Create Quorum Certificate<br/>QC(Block, Signers, AggSig)"]
+    S --> T["ğŸ“¡ Broadcast QC<br/>Send to all nodes"]
+    
+    T --> U["ğŸ“¥ Nodes Receive QC"]
+    U --> V["ğŸ”„ Sync View<br/>if QC.round > local.view:<br/>  local.view = QC.round"]
+    V --> W["ğŸ”“ Unlock Votes<br/>Remove locks for h â‰¤ QC.height"]
+    
+    W --> X{"Two-Chain Rule?<br/>QC.parent_qc exists?"}
+    
+    X -->|No| Y["â³ Wait for Next QC"]
+    Y --> O
+    
+    X -->|Yes| Z["âœ… Block Committed<br/>Two-chain rule satisfied"]
+    Z --> AA["âš™ï¸ Execute Transactions<br/>Update State Root"]
+    AA --> AB["ğŸ’¾ Block Finalized"]
+    AB --> AC["ğŸ End"]
+    
+    O --> AC
+    E --> AC
+    
+    style A fill:#ff6b6b,stroke:#c92a2a,color:#fff
+    style F fill:#a78bfa,stroke:#7c3aed,color:#fff
+    style I fill:#4dabf7,stroke:#1971c2,color:#fff
+    style S fill:#51cf66,stroke:#2f9e44,color:#fff
+    style V fill:#ffd43b,stroke:#f59f00,color:#000
+    style W fill:#ffd43b,stroke:#f59f00,color:#000
+    style Z fill:#51cf66,stroke:#2f9e44,color:#fff
diff --git a/en/flowcharts/mermaid/06_distributed_execution_improved.mmd b/en/flowcharts/mermaid/06_distributed_execution_improved.mmd
new file mode 100644
index 0000000..f4b1b1d
--- /dev/null
+++ b/en/flowcharts/mermaid/06_distributed_execution_improved.mmd
@@ -0,0 +1,63 @@
+graph TD
+    A["ğŸš€ Block Committed<br/>Ready for Execution"] --> B["ğŸ“‹ Categorize Transactions<br/>1. Retry (high priority)<br/>2. Priority (CommitmentProof)<br/>3. Normal"]
+    
+    B --> C["ğŸŸ¢ Execute Retry Transactions<br/>Failed in previous blocks"]
+    C --> D["ğŸ“Š Detect Conflicts<br/>DependencyGraph"]
+    
+    D --> E{"Conflict<br/>Detected?"}
+    
+    E -->|No| F["âœ… Execute Successfully<br/>Update State"]
+    E -->|Yes| G["ğŸ” Livelock Check<br/>Cycle Detection"]
+    
+    G --> H{"Cycle<br/>Detected?"}
+    
+    H -->|No| I["âš™ï¸ Resolve Conflict<br/>Choose winner"]
+    I --> J["ğŸŸ¡ Defer Loser<br/>Retry in next block"]
+    J --> F
+    
+    H -->|Yes| K["ğŸš¨ Cycle Found<br/>Deadlock Prevention"]
+    K --> L["â¸ï¸ Defer Transaction<br/>Queue for retry"]
+    L --> F
+    
+    F --> M["ğŸŸ¢ Execute Priority Transactions<br/>With CommitmentProof"]
+    M --> N["ğŸ”— Cross-Shard Coordination<br/>Verify CommitmentProof"]
+    N --> O{"Proof<br/>Valid?"}
+    
+    O -->|No| P["âŒ Reject<br/>Invalid proof"]
+    P --> M
+    
+    O -->|Yes| Q["âœ… Execute<br/>Update State"]
+    Q --> R["ğŸŸ¢ Execute Normal Transactions<br/>Standard execution"]
+    R --> S["âš™ï¸ Apply Writes<br/>Update Jellyfish Merkle Tree"]
+    
+    S --> T["ğŸ“Š Detect Conflicts<br/>DependencyGraph"]
+    T --> U{"Conflict?"}
+    
+    U -->|No| V["âœ… Execute Successfully"]
+    U -->|Yes| W["ğŸ” Livelock Check"]
+    
+    W --> X{"Cycle?"}
+    X -->|No| Y["âš™ï¸ Resolve Conflict"]
+    X -->|Yes| Z["â¸ï¸ Defer"]
+    
+    Y --> V
+    Z --> V
+    
+    V --> AA["ğŸ’¾ Calculate State Root<br/>JMT Root Hash"]
+    AA --> AB{"State Root<br/>Matches?"}
+    
+    AB -->|No| AC["âŒ Execution Error<br/>State mismatch"]
+    AB -->|Yes| AD["âœ… Block Finalized<br/>State committed"]
+    
+    AD --> AE["ğŸ“‹ Update Mempool<br/>- Remove executed<br/>- Retry deferred<br/>- Remove aborted"]
+    AE --> AF["ğŸ Execution Complete"]
+    
+    style A fill:#ff6b6b,stroke:#c92a2a,color:#fff
+    style B fill:#4dabf7,stroke:#1971c2,color:#fff
+    style C fill:#51cf66,stroke:#2f9e44,color:#fff
+    style M fill:#51cf66,stroke:#2f9e44,color:#fff
+    style R fill:#51cf66,stroke:#2f9e44,color:#fff
+    style G fill:#da77f2,stroke:#9c36b5,color:#fff
+    style K fill:#da77f2,stroke:#9c36b5,color:#fff
+    style W fill:#da77f2,stroke:#9c36b5,color:#fff
+    style AD fill:#51cf66,stroke:#2f9e44,color:#fff
diff --git a/en/flowcharts/mermaid/07_complete_height_cycle_corrected.mmd b/en/flowcharts/mermaid/07_complete_height_cycle_corrected.mmd
new file mode 100644
index 0000000..078cb9c
--- /dev/null
+++ b/en/flowcharts/mermaid/07_complete_height_cycle_corrected.mmd
@@ -0,0 +1,57 @@
+graph TD
+    A["ğŸš€ Epoch Start<br/>Height = 0, Round = 0"] --> B["ğŸ‘‘ Leader Election<br/>Leader = Validator[Height % N]"]
+    B --> C["ğŸ“ Propose Block<br/>Block(Height, Round, Txs)"]
+    C --> D["ğŸ“¥ Nodes Receive"]
+    D --> E["âœ… Validate Block"]
+    
+    E -->|Invalid| F["âŒ Reject"]
+    F --> G["â±ï¸ Timeout"]
+    
+    E -->|Valid| H["ğŸ”’ Check Vote Lock<br/>voted_heights[Height]?"]
+    
+    H -->|Locked| I["ğŸš« Cannot Vote<br/>Already locked"]
+    I --> G
+    
+    H -->|Not Locked| J["ğŸ—³ï¸ Vote on Block"]
+    J --> K["ğŸ“Š Collect Votes"]
+    K --> L{"2f+1 Votes?"}
+    
+    L -->|No| M["â±ï¸ Timeout"]
+    M --> N["ğŸ”„ View Change<br/>Round += 1"]
+    N --> O["ğŸ”“ Unlock Votes<br/>Remove all locks"]
+    O --> B
+    
+    L -->|Yes| P["âœï¸ Aggregate Signatures<br/>BLS12-381"]
+    P --> Q["ğŸ–ï¸ Create QC<br/>QC(Height, Round)"]
+    Q --> R["ğŸ“¡ Broadcast QC"]
+    
+    R --> S["ğŸ“¥ Receive QC"]
+    S --> T["ğŸ”„ Sync View<br/>if QC.round > local.view:<br/>  local.view = QC.round"]
+    T --> U["ğŸ”“ Unlock Votes<br/>Remove locks â‰¤ QC.height"]
+    
+    U --> V{"Two-Chain Rule?<br/>Parent QC exists?"}
+    
+    V -->|No| W["â³ Wait for Next QC"]
+    W --> N
+    
+    V -->|Yes| X["âœ… Commit Block"]
+    X --> Y["âš™ï¸ Execute Transactions"]
+    Y --> Z["ğŸ’¾ Update State Root"]
+    
+    Z --> AA{"Epoch End?<br/>Height >= Threshold"}
+    
+    AA -->|No| AB["â• Next Height<br/>Height += 1<br/>Round = 0"]
+    AB --> B
+    
+    AA -->|Yes| AC["ğŸ‰ New Epoch<br/>Height += 1<br/>Round = 0"]
+    AC --> A
+    
+    G --> AD["â±ï¸ View Change Timer<br/>Timeout X seconds"]
+    AD --> N
+    
+    style A fill:#ff6b6b,stroke:#c92a2a,color:#fff
+    style X fill:#51cf66,stroke:#2f9e44,color:#fff
+    style Q fill:#4dabf7,stroke:#1971c2,color:#fff
+    style T fill:#ffd43b,stroke:#f59f00,color:#000
+    style U fill:#ffd43b,stroke:#f59f00,color:#000
+    style H fill:#a78bfa,stroke:#7c3aed,color:#fff
diff --git a/en/flowcharts/mermaid/08_failure_handling_view_change_corrected.mmd b/en/flowcharts/mermaid/08_failure_handling_view_change_corrected.mmd
new file mode 100644
index 0000000..55deebd
--- /dev/null
+++ b/en/flowcharts/mermaid/08_failure_handling_view_change_corrected.mmd
@@ -0,0 +1,48 @@
+graph TD
+    A["â±ï¸ Round Timeout<br/>Leader Does Not Propose"] --> B["ğŸš¨ Detect Failure<br/>Waited X seconds"]
+    B --> C["ğŸ”“ Unlock Vote<br/>Remove Vote Locks"]
+    C --> D["â• Increment View<br/>View += 1<br/>Round += 1"]
+    D --> E["ğŸ‘‘ New Leader<br/>Leader = Validator[Round % N]"]
+    E --> F{"New Leader<br/>Honest?"}
+    
+    F -->|No| G["â±ï¸ Timeout Again<br/>Repeat View Change"]
+    G --> D
+    
+    F -->|Yes| H["ğŸ“ New Leader Proposes<br/>Block with HighQC"]
+    H --> I["ğŸ”„ Synchronization<br/>Nodes Receive Proposal"]
+    I --> J["âœ… Validate Block<br/>- Signature<br/>- Merkle Root<br/>- State Root"]
+    
+    J -->|Invalid| K["âŒ Reject<br/>New Timeout"]
+    K --> D
+    
+    J -->|Valid| L["ğŸ”’ Check Vote Lock<br/>voted_heights[Height]?"]
+    
+    L -->|Locked| M["ğŸš« Cannot Vote<br/>Already locked"]
+    M --> K
+    
+    L -->|Not Locked| N["ğŸ—³ï¸ Vote on Block"]
+    N --> O["ğŸ“Š Collect Votes<br/>2f+1 Required"]
+    O --> P{"Quorum<br/>Reached?"}
+    
+    P -->|No| Q["â³ Wait for More Votes"]
+    Q --> K
+    
+    P -->|Yes| R["âœï¸ Aggregate Signatures<br/>BLS12-381 Aggregation"]
+    R --> S["ğŸ–ï¸ Create QC<br/>QC(Height, Round)"]
+    S --> T["ğŸ“¡ Broadcast QC<br/>Send to all nodes"]
+    
+    T --> U["ğŸ“¥ Nodes Receive QC"]
+    U --> V["ğŸ”„ Sync View<br/>if QC.round > local.view:<br/>  local.view = QC.round"]
+    V --> W["ğŸ”“ Unlock Votes<br/>Remove locks â‰¤ QC.height"]
+    
+    W --> X["âœ… System Recovers<br/>Consensus Restored"]
+    X --> Y["ğŸ Back to Normal<br/>Continue Consensus"]
+    
+    style A fill:#ff6b6b,stroke:#c92a2a,color:#fff
+    style C fill:#ffd43b,stroke:#f59f00,color:#000
+    style D fill:#ffd43b,stroke:#f59f00,color:#000
+    style E fill:#51cf66,stroke:#2f9e44,color:#fff
+    style H fill:#4dabf7,stroke:#1971c2,color:#fff
+    style V fill:#ffd43b,stroke:#f59f00,color:#000
+    style W fill:#ffd43b,stroke:#f59f00,color:#000
+    style X fill:#51cf66,stroke:#2f9e44,color:#fff
diff --git a/en/guides/DETAILED_LEARNING_GUIDE_EN.md b/en/guides/DETAILED_LEARNING_GUIDE_EN.md
index 24b1d19..14ac618 100644
--- a/en/guides/DETAILED_LEARNING_GUIDE_EN.md
+++ b/en/guides/DETAILED_LEARNING_GUIDE_EN.md
@@ -154,8 +154,8 @@ Someone claims: "TX2 is in the block"
 Proof path:
 - Hash(TX2) = xyz789
 - Hash(TX1) = def456
-- Hash(TX1 || TX2) = ghi012
-- Hash(ghi012 || Hash(TX3||TX4)) = abc123 âœ… (matches root!)
+- Hash(TX1 | TX2) = ghi012
+- Hash(ghi012 | Hash(TX3|TX4)) = abc123 âœ… (matches root!)
 
 Conclusion: TX2 is definitely in the block
 ```
@@ -245,7 +245,7 @@ pub const DOMAIN_BLOCK_VOTE: &[u8] = b"BLOCK_VOTE";
 pub const DOMAIN_STATE_PROVISION: &[u8] = b"STATE_PROVISION";
 pub const DOMAIN_EXEC_VOTE: &[u8] = b"EXEC_VOTE";
 
-// The actual message that is signed is: DOMAIN_TAG || content
+// The actual message that is signed is: DOMAIN_TAG | content
 fn block_vote_message(
     shard_group: ShardGroupId,
     height: u64,
@@ -266,11 +266,11 @@ fn block_vote_message(
 
 ```
 Validator V1 signs:
-Message = "BLOCK_VOTE" || shard=1 || height=10 || round=0 || hash=abc...
+Message = "BLOCK_VOTE" | shard=1 | height=10 | round=0 | hash=abc...
 Signature = Sign(Message, V1_private_key)
 
 Attacker tries to reuse signature for STATE_PROVISION:
-Message2 = "STATE_PROVISION" || ... (same content)
+Message2 = "STATE_PROVISION" | ... (same content)
 Verification: Verify(Signature, Message2, V1_public_key)
 Result: âŒ FAILS! (Signature is for Message, not Message2)
 ```
@@ -279,12 +279,12 @@ Result: âŒ FAILS! (Signature is for Message, not Message2)
 
 ```
 Without shard in domain:
-- Shard 0 validator signs: "BLOCK_VOTE" || height=10 || ...
+- Shard 0 validator signs: "BLOCK_VOTE" | height=10 | ...
 - Attacker could reuse this signature in Shard 1
 
 With shard in domain:
-- Shard 0 validator signs: "BLOCK_VOTE" || shard=0 || height=10 || ...
-- Shard 1 validator signs: "BLOCK_VOTE" || shard=1 || height=10 || ...
+- Shard 0 validator signs: "BLOCK_VOTE" | shard=0 | height=10 | ...
+- Shard 1 validator signs: "BLOCK_VOTE" | shard=1 | height=10 | ...
 - Signatures are incompatible across shards âœ…
 ```
 
@@ -454,122 +454,154 @@ Quorum not reached â†’ Block B rejected âœ…
 
 ---
 
-## 2.3. Ensuring Liveness: The Unlock Rule
+## 2.3. Ensuring Liveness: View Synchronization and the Unlock Rule
 
-`Vote Locking` is essential for safety, but it can paralyze consensus if validators become locked on conflicting proposals that never reach quorum. The **Unlock Rule** solves this.
+`Vote Locking` is essential for safety, but it can paralyze consensus if validators become locked on conflicting proposals that never reach quorum. The `maybe_unlock_for_qc` function provides two critical mechanisms to ensure the network remains live.
 
-**Rule**: When a validator sees a QC for height `H`, it knows the decision at height `H` is final. Therefore, it can safely discard all its `voted_heights` for heights `â‰¤ H`.
+**Mechanism 1: View Synchronization**
+If a validator is behind the rest of the network (e.g., it's in round 2, but the network is already in round 5), it needs a way to catch up. When this validator sees a QC from a higher round, it immediately advances its own local view to match the QC's round. This ensures validators stay synchronized with the network's progress.
+
+**Mechanism 2: The Unlock Rule**
+When a validator sees a QC for height `H`, it knows the network has certified a block at that height. It can therefore safely discard its own vote locks for any height `â‰¤ H`. This prevents a validator from being permanently stuck on an old, failed proposal, allowing it to vote for new proposals at higher heights.
 
 ```rust
 // Location: crates/bft/src/state.rs
 fn maybe_unlock_for_qc(&mut self, qc: &QuorumCertificate) {
+    if qc.is_genesis() {
+        return;
+    }
+
+    // Mechanism 1: View Synchronization
+    // Advance our view to match the QC's round, ensuring we keep up with the network.
+    if qc.round > self.view {
+        self.view = qc.round;
+    }
+
+    // Mechanism 2: The Unlock Rule
+    // Find all vote locks for heights at or below the QC's height.
     let qc_height = qc.height.0;
-    // Discard all locks for heights that are now irrelevant.
-    self.voted_heights.retain(|&height, _| height > qc_height);
+    let heights_to_unlock: Vec<u64> = self
+        .voted_heights
+        .keys()
+        .filter(|h| **h <= qc_height)
+        .copied()
+        .collect();
+
+    // Remove the identified locks, freeing the validator to vote in the future.
+    for height in heights_to_unlock {
+        self.voted_heights.remove(&height);
+    }
 }
 ```
 
-### Livelock Scenario Without Unlock Rule
+### How These Mechanisms Prevent Livelock
+
+Let's revisit the scenario where consensus gets stuck.
 
 ```
-Height 10, Round 0:
-V1 votes for Block A â†’ voted_heights[10] = Block A
-V2 votes for Block B â†’ voted_heights[10] = Block B
-V3 offline
+// Initial State: Consensus is stuck at Height 10.
+// V1 is locked on Block A, V2 is locked on Block B.
+// No new blocks can get a QC at this height.
 
-Nope quorum reached (only 2 votes)
-View change to Round 1
+// Liveness in Action:
+// 1. The network continues to make progress at other heights.
+//    Eventually, a QC for a higher height, say QC_11, is formed and broadcast.
 
-Height 10, Round 1:
-V3 proposes Block C
-V1 tries to vote: voted_heights[10] = Block A â‰  Block C â†’ CANNOT vote
-V2 tries to vote: voted_heights[10] = Block B â‰  Block C â†’ CANNOT vote
-V3 votes for Block C
+// 2. V1 and V2 receive QC_11.
+//    They both call maybe_unlock_for_qc(&QC_11).
 
-Only 1 vote â†’ No quorum
-CONSENSUS STUCK! âŒ
-```
+// 3. View Synchronization:
+//    V1 and V2 update their local view to match QC_11.round, synchronizing them.
 
-### How Unlock Rule Fixes This
+// 4. Unlock Rule is Applied:
+//    The function collects heights to unlock: h <= 11.
+//    The lock for height 10 is found (since 10 <= 11).
+//    self.voted_heights.remove(&10) is called.
+//    V1 and V2 are now UNLOCKED for height 10. âœ…
 
+// 5. Consensus Resumes:
+//    When a new proposal for Height 12 arrives, both V1 and V2 are free to vote,
+//    and the consensus process can continue.
 ```
-Height 10, Round 0:
-V1 votes for Block A â†’ voted_heights[10] = Block A
-V2 votes for Block B â†’ voted_heights[10] = Block B
-V3 offline
 
-No quorum reached
+### ğŸ§  Reflection
 
-Height 9 QC forms (from previous round)
-All validators receive QC 9
+**Question**: Why is it safe to remove locks for heights `â‰¤ qc_height`?
 
-Unlock:
-voted_heights.retain(|height, _| height > 9)
-voted_heights[10] is REMOVED! âœ…
+**Answer**: Because a QC for height `H` is a cryptographic proof that 2f+1 validators have agreed on a block at that height. This makes the chain up to `H` certified. Any conflicting blocks at those heights can never get a QC due to the quorum intersection property. It is therefore safe to discard old locks, as they no longer contribute to the safety of the consensus.
 
-Height 10, Round 1:
-V3 proposes Block C
-V1 tries to vote: voted_heights[10] = None â†’ CAN vote âœ…
-V2 tries to vote: voted_heights[10] = None â†’ CAN vote âœ…
-V3 votes for Block C
+**Follow-up Question**: What if a validator is so far behind it never sees a QC for the height it's locked on?
 
-3 votes â†’ Quorum reached â†’ Consensus advances! âœ…
-```
+**Answer**: That's the elegance of the design! The unlock rule works with *any* QC for a height greater than or equal to the locked height. As long as the network as a whole is making progress (which it will with an honest majority), a validator will eventually see a QC from the future that is high enough to unlock its past vote, ensuring it can always rejoin the consensus.
 
-### ğŸ§  Reflection
+---
 
-**Question**: Unlock rule removes locks for heights â‰¤ qc_height. Why not remove locks for heights < qc_height?
+## 2.4. Proposing Blocks: The `on_proposal_timer` Function
 
-**Answer**: Because height qc_height is already finalized (two-chain rule), so there's no risk of conflict there. But heights > qc_height can still have conflicts, so we keep the locks.
+The `on_proposal_timer` function is the pacemaker of the consensus engine. Instead of being a simple timeout for view changes, it is the primary trigger for a validator to **propose a new block** if it is the current leader. It is a complex function that orchestrates the core logic of block creation.
 
-**Follow-up Question**: What if a validator never sees a QC? Won't it stay locked forever?
+Here is a breakdown of its responsibilities:
 
-**Answer**: No! The unlock rule is applied whenever ANY QC is seen, even if it's not for the exact height you're locked on. As long as the network makes progress (which it will with an honest majority), you'll eventually see a QC that unlocks you.
+1.  **Determine Next Height**: It calculates the `next_height` for the new block, which is `latest_qc.height + 1`.
+2.  **Check Leadership**: It verifies if the current validator is the designated proposer for the `next_height` and current `round` using the formula `(height + round) % num_validators`.
+3.  **Check Vote Lock**: It checks if the validator has already voted at `next_height`. If so, it cannot propose a new, different block, which would violate the vote locking safety rule.
+4.  **Assemble Block**: If all checks pass, it gathers ready transactions from the Mempool, along with any necessary `CommitmentProof`s for cross-shard transactions.
+5.  **Build and Broadcast**: It constructs the new `Block` with the `latest_qc` as its parent and broadcasts it to the network.
 
----
+```rust
+// Simplified logic of on_proposal_timer in crates/bft/src/state.rs
+pub fn on_proposal_timer(
+    &mut self,
+    ready_txs: &ReadyTransactions,
+    // ... other parameters
+) -> Vec<Action> {
+    // 1. Determine the next height to propose at.
+    let next_height = self.latest_qc.as_ref().map_or(self.committed_height + 1, |qc| qc.height.0 + 1);
+    let round = self.view;
+
+    // 2. Check if we are the leader for this height and round.
+    if !self.should_propose(next_height, round) {
+        return vec![/* Reschedule timer */];
+    }
 
-## 2.4. Implicit View Changes
+    // 3. Check vote lock: if we already voted at this height, we can't propose a different block.
+    if self.voted_heights.contains_key(&next_height) {
+        return vec![/* Reschedule timer */];
+    }
 
-Instead of a complex message protocol to change leaders, HotStuff-2 uses local timeouts. If a proposer fails to produce a block in time, each validator independently advances to the next round. The new leader is determined deterministically by the formula `(height + new_round) % num_validators`.
+    // 4. Assemble the block's contents.
+    let parent_qc = self.latest_qc.clone().unwrap_or_else(QuorumCertificate::genesis);
+    let transactions = ready_txs.all_transactions(); // Simplified
 
-This dramatically simplifies the protocol, making it more robust and easier to analyze.
+    // 5. Build the new block and broadcast it.
+    let new_block = Block::new(parent_qc, next_height, round, transactions, ...);
+    self.broadcast_block(new_block);
 
-```rust
-// Location: crates/bft/src/state.rs
-pub fn on_proposal_timer(&mut self) -> Vec<Action> {
-    // If proposer didn't produce block in time
-    self.view += 1;
-    self.view_at_height_start = self.view;
-    
-    // Next proposer changes automatically
-    // proposer = (height + new_round) % num_validators
+    vec![/* ... other actions ... */]
 }
 ```
 
-### Example Timeline
+### What About View Changes?
 
-```
-Height 10, Round 0:
-Proposer: (10 + 0) % 4 = V2
-V2 doesn't produce block in time
+If a leader fails to produce a block, other validators won't receive a valid proposal. After a certain period, a separate `on_view_change_timer` fires on each validator. This is the timer that increments the local `view` (round), causing the validators to move to the next leader. The `on_proposal_timer` then allows the *new* leader to build and propose a block.
 
-Timeout (100ms):
-V0 advances: view = 1
-V1 advances: view = 1
-V2 advances: view = 1
-V3 advances: view = 1
+### ğŸ§  Reflection
 
-Height 10, Round 1:
-Proposer: (10 + 1) % 4 = V3
-V3 proposes block
-Consensus advances
-```
+**Question**: Why is the `on_proposal_timer` so complex? Why not just have the leader propose a block whenever it wants?
 
-### ğŸ§  Reflection
+**Answer**: The strict checks within `on_proposal_timer` are essential for the safety and liveness of the protocol. Checking leadership ensures only one validator proposes at a time. Checking the vote lock prevents a validator from equivocating and violating safety. Determining the height from the latest QC ensures the chain always extends from the most advanced certified block, contributing to liveness.
+
+---
+
+## 2.5. Keeping Time: How Validators Stay Synchronized
+
+A key challenge in a distributed system is ensuring all participants have a roughly synchronized view of the state, in this case, the current `round` (or `view`). If validators have wildly different local views, electing a leader and reaching a quorum becomes impossible.
+
+Hyperscale-rs solves this elegantly without a central clock:
 
-**Question**: If each validator advances its round locally, how do they synchronize?
+**Synchronization via QCs**: The Quorum Certificate (QC) acts as a network-wide "beacon of time". As we saw in the `maybe_unlock_for_qc` function, whenever a validator receives a QC with a round number higher than its own, it immediately fast-forwards its local round to match the QC's round. Since QCs are broadcast to all validators, this single mechanism ensures that any validator that falls behind will quickly catch up to the rest of the network.
 
-**Answer**: Via **QCs**! When you receive a QC in round R, you know the quorum is in round R, so you advance to round R+1. This ensures all validators stay roughly synchronized.
+This creates a powerful feedback loop: progress (in the form of QCs) drives synchronization, and synchronization enables further progress.
 
 ---
 
diff --git a/pt/guias/GUIA_APRENDIZADO.md b/pt/guias/GUIA_APRENDIZADO.md
index 579d3b0..49626c9 100644
--- a/pt/guias/GUIA_APRENDIZADO.md
+++ b/pt/guias/GUIA_APRENDIZADO.md
@@ -1,4 +1,4 @@
-# ğŸ“ Guia de Aprendizado: Hyperscale-RS
+'''# ğŸ“ Guia de Aprendizado: Hyperscale-RS
 
 ## IntroduÃ§Ã£o
 
@@ -161,8 +161,8 @@ AlguÃ©m diz: "TX2 estÃ¡ no bloco"
 Prova:
 - Hash(TX2) = xyz789
 - Hash(TX1) = def456
-- Hash(TX1 || TX2) = ghi012
-- Hash(ghi012 || TX3) = abc123 âœ… (match root!)
+- Hash(TX1 | TX2) = ghi012
+- Hash(ghi012 | TX3) = abc123 âœ… (match root!)
 
 ConclusÃ£o: TX2 definitivamente estÃ¡ no bloco
 ```
@@ -277,7 +277,7 @@ pub const DOMAIN_BLOCK_VOTE: &[u8] = b"BLOCK_VOTE";
 pub const DOMAIN_STATE_PROVISION: &[u8] = b"STATE_PROVISION";
 pub const DOMAIN_EXEC_VOTE: &[u8] = b"EXEC_VOTE";
 
-// Mensagem assinada = DOMAIN_TAG || conteÃºdo
+// Mensagem assinada = DOMAIN_TAG | conteÃºdo
 fn block_vote_message(
     shard_group: ShardGroupId,
     height: u64,
@@ -298,11 +298,11 @@ fn block_vote_message(
 
 ```
 Validador V1 assina:
-Message = "BLOCK_VOTE" || shard=1 || height=10 || round=0 || hash=abc...
+Message = "BLOCK_VOTE" | shard=1 | height=10 | round=0 | hash=abc...
 Signature = Sign(Message, V1_private_key)
 
 Atacante tenta reusar assinatura para STATE_PROVISION:
-Message2 = "STATE_PROVISION" || ... (mesmo conteÃºdo)
+Message2 = "STATE_PROVISION" | ... (mesmo conteÃºdo)
 VerificaÃ§Ã£o: Verify(Signature, Message2, V1_public_key)
 Resultado: âŒ FALHA! (Signature Ã© para Message, nÃ£o Message2)
 ```
@@ -505,1025 +505,419 @@ Height 1:
 
 ---
 
-## 2.3 Vote Locking (SeguranÃ§a)
+## 2.3. SeguranÃ§a e Liveness: Bloqueio de Voto e a Regra de Desbloqueio
 
-### Problema
-
-```
-Height 10, Round 0:
-V0 propÃµe Block A
-V1 vota em Block A
-V2 vota em Block A
-V3 offline
+Para garantir a seguranÃ§a, o HotStuff-2 usa uma regra de **Bloqueio de Voto (Vote Locking)**: uma vez que um validador vota em um bloco a uma certa altura, ele nÃ£o pode votar em um bloco *diferente* na mesma altura. Isso previne que um validador malicioso vote em duas cadeias conflitantes.
 
-Round 0 timeout â†’ View change para Round 1
+No entanto, essa regra sozinha pode travar o consenso (um problema de **Liveness**). Se validadores diferentes se bloquearem em blocos conflitantes que nunca atingem um quÃ³rum, ninguÃ©m consegue mais votar. A funÃ§Ã£o `maybe_unlock_for_qc` resolve isso com dois mecanismos cruciais.
 
-Height 10, Round 1:
-V3 (novo proposer) propÃµe Block B (diferente!)
-V1 quer votar em Block B
-V2 quer votar em Block B
-
-Resultado: Dois blocos diferentes em height 10!
-VIOLAÃ‡ÃƒO DE SEGURANÃ‡A! âŒ
-```
+**Mecanismo 1: SincronizaÃ§Ã£o de View (Round)**
+Se um validador fica para trÃ¡s, ele precisa se atualizar. Ao ver um QC com um `round` (ou `view`) mais alto que o seu, ele imediatamente avanÃ§a seu `view` local para corresponder ao do QC, mantendo-se sincronizado com a rede.
 
-### SoluÃ§Ã£o: Vote Locking
+**Mecanismo 2: A Regra de Desbloqueio (Unlock Rule)**
+Ao ver um QC para a altura `H`, um validador sabe que a rede certificou um bloco naquela altura. Portanto, Ã© seguro descartar seus bloqueios de voto para qualquer altura `â‰¤ H`, permitindo que ele volte a participar do consenso.
 
 ```rust
-// Arquivo: crates/bft/src/state.rs
-
-pub voted_heights: HashMap<u64, (Hash, u64)>
-
-// Quando votamos em um bloco:
-fn try_vote_on_block(&mut self, block_hash: Hash, height: u64, round: u64) {
-    // Verificar se jÃ¡ votamos em altura
-    if let Some(&(existing_hash, _)) = self.voted_heights.get(&height) {
-        if existing_hash != block_hash {
-            // JÃ¡ votamos em outro bloco â†’ NÃƒO VOTAMOS
-            debug!("Vote locking: already voted for different block");
-            return vec![];
-        }
+// LocalizaÃ§Ã£o: crates/bft/src/state.rs
+fn maybe_unlock_for_qc(&mut self, qc: &QuorumCertificate) {
+    if qc.is_genesis() {
+        return;
     }
-    
-    // Registrar voto
-    self.voted_heights.insert(height, (block_hash, round));
-    
-    // Criar e enviar BlockVote
-    self.create_vote(block_hash, height, round)
-}
-```
-
-### Como Funciona
-
-```
-Height 10, Round 0:
-V1 vota em Block A
-voted_heights[10] = (Block A, round 0)
-
-Height 10, Round 1:
-V3 propÃµe Block B
-V1 recebe Block B
-V1 tenta votar em Block B
-VerificaÃ§Ã£o: voted_heights[10] = (Block A, round 0) â‰  Block B
-Resultado: V1 NÃƒO vota em Block B âœ… (safety preserved)
-```
-
-### ğŸ§  ReflexÃ£o
-
-**Pergunta**: Vote locking previne que V1 vote em Block B. Mas e se Block B Ã© realmente melhor? Consenso nÃ£o fica travado?
-
-**Resposta**: Boa pergunta! Vamos ver a soluÃ§Ã£o: **Unlock rule**.
-
----
 
-## 2.4 Unlock Rule (Liveness)
-
-### Problema
-
-```
-Height 10, Round 0:
-V1 vota em Block A â†’ voted_heights[10] = Block A
-V2 vota em Block B â†’ voted_heights[10] = Block B
-V3 offline
-
-Nenhum atinge quorum (sÃ³ 2 votos)
-View change para Round 1
-
-Height 10, Round 1:
-V3 propÃµe Block C
-V1 quer votar em Block C
-V1 tenta: voted_heights[10] = Block A â‰  Block C
-V1 NÃƒO vota
-
-V2 quer votar em Block C
-V2 tenta: voted_heights[10] = Block B â‰  Block C
-V2 NÃƒO vota
-
-V3 vota em Block C (1 voto)
-CONSENSO TRAVADO! âŒ
-```
-
-### SoluÃ§Ã£o: Unlock Rule
-
-```rust
-// Arquivo: crates/bft/src/state.rs
+    // Mecanismo 1: SincronizaÃ§Ã£o de View
+    // AvanÃ§a nossa view para corresponder Ã  do QC, garantindo que acompanhemos a rede.
+    if qc.round > self.view {
+        self.view = qc.round;
+    }
 
-fn maybe_unlock_for_qc(&mut self, qc: &QuorumCertificate) {
+    // Mecanismo 2: A Regra de Desbloqueio
+    // Encontra todos os bloqueios de voto para alturas iguais ou inferiores Ã  do QC.
     let qc_height = qc.height.0;
-    
-    // Remover locks em alturas â‰¤ qc_height
-    self.voted_heights.retain(|&height, _| height > qc_height);
+    let heights_to_unlock: Vec<u64> = self
+        .voted_heights
+        .keys()
+        .filter(|h| **h <= qc_height)
+        .copied()
+        .collect();
+
+    // Remove os bloqueios identificados, liberando o validador para votar no futuro.
+    for height in heights_to_unlock {
+        self.voted_heights.remove(&height);
+    }
 }
 ```
 
-### Como Funciona
+### Como Isso Evita o Travamento (Livelock)
 
-```
-Height 10, Round 0:
-V1 vota em Block A â†’ voted_heights[10] = Block A
-V2 vota em Block B â†’ voted_heights[10] = Block B
-Nenhum atinge quorum
-
-Height 9 QC forma (de round anterior)
-Todos recebem QC 9
-
-Unlock:
-voted_heights.retain(|height, _| height > 9)
-voted_heights[10] Ã© removido! âœ…
-
-Height 10, Round 1:
-V3 propÃµe Block C
-V1 tenta votar: voted_heights[10] = None
-V1 PODE votar em Block C! âœ…
-V2 tenta votar: voted_heights[10] = None
-V2 PODE votar em Block C! âœ…
-V3 vota em Block C
-
-3 votos â†’ Quorum â†’ Consenso avanÃ§a! âœ…
-```
-
-### ğŸ§  ReflexÃ£o
-
-**Pergunta**: Unlock rule remove locks em alturas â‰¤ qc_height. Por que nÃ£o remover locks em alturas < qc_height?
-
-**Resposta**: Porque altura qc_height jÃ¡ foi commitada (two-chain rule), entÃ£o nÃ£o hÃ¡ risco de conflito nela. Mas alturas > qc_height ainda podem ter conflitos, entÃ£o mantemos os locks.
-
----
+Vamos revisitar o cenÃ¡rio onde o consenso trava:
 
-## 2.5 View Changes (Implicit)
-
-### Conceito
+```
+// Estado Inicial: Consenso travado na Altura 10.
+// V1 estÃ¡ bloqueado no Bloco A, V2 estÃ¡ bloqueado no Bloco B.
+// Nenhum novo bloco consegue um QC nesta altura.
 
-**HotStuff-2 usa view changes implÃ­citos**: Cada validador avanÃ§a seu round localmente no timeout.
+// Liveness em AÃ§Ã£o:
+// 1. A rede continua a progredir em outras alturas.
+//    Eventualmente, um QC para uma altura maior, digamos QC_11, Ã© formado e transmitido.
 
-```rust
-// Arquivo: crates/bft/src/state.rs
+// 2. V1 e V2 recebem o QC_11.
+//    Ambos chamam a funÃ§Ã£o maybe_unlock_for_qc(&QC_11).
 
-pub fn on_proposal_timer(&mut self) -> Vec<Action> {
-    // Se proposer nÃ£o produziu bloco em tempo
-    self.view += 1;
-    self.view_at_height_start = self.view;
-    
-    // PrÃ³ximo proposer muda automaticamente
-    // proposer = (height + new_round) % num_validators
-}
-```
+// 3. SincronizaÃ§Ã£o de View:
+//    V1 e V2 atualizam sua view local para corresponder a QC_11.round, sincronizando-se.
 
-### Exemplo
+// 4. Regra de Desbloqueio Ã© Aplicada:
+//    A funÃ§Ã£o coleta as alturas para desbloquear: h <= 11.
+//    O bloqueio para a altura 10 Ã© encontrado (pois 10 <= 11).
+//    self.voted_heights.remove(&10) Ã© chamado.
+//    V1 e V2 estÃ£o agora DESBLOQUEADOS para a altura 10. âœ…
 
-```
-Height 10, Round 0:
-Proposer: (10 + 0) % 4 = V2
-V2 nÃ£o produz bloco em tempo
-
-Timeout (100ms):
-V0 avanÃ§a: view = 1
-V1 avanÃ§a: view = 1
-V2 avanÃ§a: view = 1
-V3 avanÃ§a: view = 1
-
-Height 10, Round 1:
-Proposer: (10 + 1) % 4 = V3
-V3 propÃµe bloco
-Consenso avanÃ§a
+// 5. Consenso Retoma:
+//    Quando uma nova proposta para a Altura 12 chegar, tanto V1 quanto V2 estarÃ£o livres para votar,
+//    e o processo de consenso pode continuar.
 ```
 
-### BenefÃ­cio: Sem Protocolo Separado
+### ğŸ§  ReflexÃ£o
 
-```
-HotStuff original:
-â”œâ”€ Protocolo de consenso
-â”œâ”€ Protocolo de view change (separado)
-â””â”€ Protocolo de sincronizaÃ§Ã£o
-
-HotStuff-2:
-â”œâ”€ Protocolo de consenso
-â”œâ”€ View changes implÃ­citos (sem protocolo)
-â””â”€ SincronizaÃ§Ã£o via QCs
-```
+**Pergunta**: Por que Ã© seguro remover bloqueios para alturas `â‰¤ qc_height`?
 
-### ğŸ§  ReflexÃ£o
+**Resposta**: Porque um QC para a altura `H` Ã© uma prova criptogrÃ¡fica de que 2f+1 validadores concordaram com um bloco naquela altura. Isso torna a cadeia atÃ© `H` certificada. Qualquer bloco conflitante nessas alturas nunca conseguirÃ¡ um QC devido Ã  propriedade de interseÃ§Ã£o de quÃ³rum. Portanto, Ã© seguro descartar bloqueios antigos, pois eles nÃ£o contribuem mais para a seguranÃ§a do consenso.
 
-**Pergunta**: Se cada validador avanÃ§a seu round localmente, como eles sincronizam?
+**Pergunta de Acompanhamento**: E se um validador estiver tÃ£o atrasado que nunca vÃª um QC para a altura em que estÃ¡ bloqueado?
 
-**Resposta**: Via **QCs**! Quando vocÃª recebe QC em round R, vocÃª sabe que quorum estÃ¡ em round R, entÃ£o vocÃª avanÃ§a para round R+1.
+**Resposta**: Essa Ã© a elegÃ¢ncia do design! A regra de desbloqueio funciona com *qualquer* QC para uma altura maior ou igual Ã  altura bloqueada. Contanto que a rede como um todo esteja progredindo (o que acontecerÃ¡ com uma maioria honesta), um validador eventualmente verÃ¡ um QC do futuro que Ã© alto o suficiente para desbloquear seu voto passado, garantindo que ele sempre possa se juntar novamente ao consenso.
 
 ---
 
-## 2.6 State Root Verification
+## 2.4. Propondo Blocos: A FunÃ§Ã£o `on_proposal_timer`
 
-### Problema
+A funÃ§Ã£o `on_proposal_timer` Ã© o marca-passo do motor de consenso. Em vez de ser um simples timeout para mudanÃ§as de view, Ã© o gatilho principal para um validador **propor um novo bloco** se ele for o lÃ­der atual. Ã‰ uma funÃ§Ã£o complexa que orquestra a lÃ³gica central da criaÃ§Ã£o de blocos.
 
-```
-Proposer V0 computa state_root especulativamente:
-state_root = hash(parent_state + certificates)
+Aqui estÃ¡ um detalhamento de suas responsabilidades:
 
-Mas V0 pode estar errado! (bug, ou malicioso)
+1.  **Determinar a PrÃ³xima Altura**: Calcula a `next_height` para o novo bloco, que Ã© `latest_qc.height + 1`.
+2.  **Verificar a LideranÃ§a**: Verifica se o validador atual Ã© o proponente designado para a `next_height` e o `round` atual usando a fÃ³rmula `(height + round) % num_validators`.
+3.  **Verificar o Bloqueio de Voto**: Verifica se o validador jÃ¡ votou na `next_height`. Se sim, ele nÃ£o pode propor um novo bloco diferente, o que violaria a regra de seguranÃ§a de bloqueio de voto.
+4.  **Montar o Bloco**: Se todas as verificaÃ§Ãµes passarem, ele reÃºne transaÃ§Ãµes prontas do Mempool, juntamente com quaisquer `CommitmentProof`s necessÃ¡rios para transaÃ§Ãµes entre shards.
+5.  **Construir e Transmitir**: ConstrÃ³i o novo `Block` com o `latest_qc` como seu pai e o transmite para a rede.
 
-Validadores V1, V2, V3 precisam verificar:
-"state_root estÃ¡ correto?"
+```rust
+// LÃ³gica simplificada de on_proposal_timer em crates/bft/src/state.rs
+pub fn on_proposal_timer(
+    &mut self,
+    ready_txs: &ReadyTransactions,
+    // ... outros parÃ¢metros
+) -> Vec<Action> {
+    // 1. Determinar a prÃ³xima altura para propor.
+    let next_height = self.latest_qc.as_ref().map_or(self.committed_height + 1, |qc| qc.height.0 + 1);
+    let round = self.view;
+
+    // 2. Verificar se somos o lÃ­der para esta altura e round.
+    if !self.should_propose(next_height, round) {
+        return vec![/* Reagendar timer */];
+    }
 
-Mas como?
-```
+    // 3. Verificar bloqueio de voto: se jÃ¡ votamos nesta altura, nÃ£o podemos propor um bloco diferente.
+    if self.voted_heights.contains_key(&next_height) {
+        return vec![/* Reagendar timer */];
+    }
 
-### SoluÃ§Ã£o: Async Verification
+    // 4. Montar o conteÃºdo do bloco.
+    let parent_qc = self.latest_qc.clone().unwrap_or_else(QuorumCertificate::genesis);
+    let transactions = ready_txs.all_transactions(); // Simplificado
 
-```rust
-// Arquivo: crates/bft/src/state.rs
+    // 5. Construir o novo bloco e transmiti-lo.
+    let new_block = Block::new(parent_qc, next_height, round, transactions, ...);
+    self.broadcast_block(new_block);
 
-fn try_vote_on_block(&mut self, block_hash: Hash, height: u64, round: u64) {
-    // ... validaÃ§Ãµes anteriores ...
-    
-    // Iniciar verificaÃ§Ãµes assÃ­ncronas em paralelo
-    let mut verification_actions = Vec::new();
-    
-    // 1. Verificar state_root (se houver certificados)
-    if self.block_needs_state_root_verification(&block) {
-        verification_actions
-            .extend(self.initiate_state_root_verification(block_hash, &block));
-    }
-    
-    // 2. Verificar transaction_root
-    if self.block_needs_transaction_root_verification(&block) {
-        verification_actions
-            .extend(self.initiate_transaction_root_verification(block_hash, &block));
-    }
-    
-    // 3. Verificar cycle proofs
-    if self.block_needs_cycle_proof_verification(&block) {
-        verification_actions
-            .extend(self.initiate_cycle_proof_verification(block_hash, &block));
-    }
-    
-    // Se houver verificaÃ§Ãµes pendentes, aguardar
-    if !verification_actions.is_empty() {
-        return verification_actions;
-    }
-    
-    // Todas as verificaÃ§Ãµes passaram â†’ Votar
-    self.create_vote(block_hash, height, round)
+    vec![/* ... outras aÃ§Ãµes ... */]
 }
 ```
 
-### Fluxo
+### E as MudanÃ§as de View?
 
-```
-1. Receber bloco com state_root = X
-2. Iniciar verificaÃ§Ã£o assÃ­ncrona (em thread pool)
-3. Enquanto verifica, continuar processando outros eventos
-4. Callback: on_state_root_verified()
-5. Se vÃ¡lido â†’ Votar
-6. Se invÃ¡lido â†’ Rejeitar bloco
-```
+Se um lÃ­der falhar em produzir um bloco, outros validadores nÃ£o receberÃ£o uma proposta vÃ¡lida. ApÃ³s um certo perÃ­odo, um `on_view_change_timer` separado dispara em cada validador. Este Ã© o timer que incrementa a `view` (round) local, fazendo com que os validadores passem para o prÃ³ximo lÃ­der. O `on_proposal_timer` entÃ£o permite que o *novo* lÃ­der construa e proponha um bloco.
 
 ### ğŸ§  ReflexÃ£o
 
-**Pergunta**: Por que nÃ£o verificar state_root antes de receber o bloco?
+**Pergunta**: Por que o `on_proposal_timer` Ã© tÃ£o complexo? Por que nÃ£o apenas fazer o lÃ­der propor um bloco quando quiser?
 
-**Resposta**: Porque vocÃª precisa das transaÃ§Ãµes do bloco para computar state_root! VocÃª sÃ³ pode verificar depois que o bloco estÃ¡ completo.
+**Resposta**: As verificaÃ§Ãµes rigorosas dentro do `on_proposal_timer` sÃ£o essenciais para a seguranÃ§a e a liveness do protocolo. Verificar a lideranÃ§a garante que apenas um validador proponha por vez. Verificar o bloqueio de voto impede que um validador se equivoque e viole a seguranÃ§a. Determinar a altura a partir do QC mais recente garante que a cadeia sempre se estenda a partir do bloco certificado mais avanÃ§ado, contribuindo para a liveness.
 
 ---
 
-## âœ… Checkpoint 2: Consenso
-
-VocÃª agora entende:
-- âœ… HotStuff-2 (3 passos)
-- âœ… Vote locking (seguranÃ§a)
-- âœ… Unlock rule (liveness)
-- âœ… View changes implÃ­citos
-- âœ… State root verification
-
-**PrÃ³ximo**: ExecuÃ§Ã£o distribuÃ­da (cross-shard coordination)
-
----
-
-# ğŸ“š MÃ³dulo 3: ExecuÃ§Ã£o DistribuÃ­da
-
-## 3.1 O Problema Cross-Shard
-
-### CenÃ¡rio
-
-```
-Shard 0: Conta A (1000 XRD)
-Shard 1: Conta B (0 XRD)
+## 2.5. Mantendo o Tempo: Como os Validadores se MantÃªm Sincronizados
 
-TransaÃ§Ã£o: "Transferir 100 XRD de A para B"
+Um desafio fundamental em um sistema distribuÃ­do Ã© garantir que todos os participantes tenham uma visÃ£o aproximadamente sincronizada do estado, neste caso, o `round` (ou `view`) atual. Se os validadores tiverem views locais muito diferentes, eleger um lÃ­der e alcanÃ§ar um quÃ³rum se torna impossÃ­vel.
 
-Problema:
-- Shard 0 executa: A = 900
-- Shard 1 executa: B = 100
-- Mas e se Shard 1 falhar? A fica com 900 e B fica com 0!
-- INCONSISTÃŠNCIA! âŒ
-```
+O Hyperscale-rs resolve isso de forma elegante sem um relÃ³gio central:
 
-### SoluÃ§Ã£o: Two-Phase Commit (2PC)
+**SincronizaÃ§Ã£o via QCs**: O Quorum Certificate (QC) atua como um "farol de tempo" para toda a rede. Como vimos na funÃ§Ã£o `maybe_unlock_for_qc`, sempre que um validador recebe um QC com um nÃºmero de round maior que o seu, ele imediatamente avanÃ§a seu round local para corresponder ao do QC. Como os QCs sÃ£o transmitidos para todos os validadores, este Ãºnico mecanismo garante que qualquer validador que fique para trÃ¡s rapidamente alcanÃ§arÃ¡ o resto da rede.
 
-```
-Fase 1 (Prepare): Shard 0 executa, gera prova
-Fase 2 (Commit): Shard 1 recebe prova, executa
-```
+Isso cria um poderoso ciclo de feedback: o progresso (na forma de QCs) impulsiona a sincronizaÃ§Ã£o, e a sincronizaÃ§Ã£o permite mais progresso.
 
 ---
 
-## 3.2 StateProvision (Fase 1)
-
-### Conceito
-
-**StateProvision** Ã© uma prova que Shard 0 executou uma transaÃ§Ã£o.
-
-```rust
-// Arquivo: crates/types/src/state_provision.rs
-
-pub struct StateProvision {
-    pub tx_hash: Hash,
-    pub source_shard: ShardGroupId,
-    pub target_shard: ShardGroupId,
-    pub block_height: BlockHeight,
-    pub block_timestamp: u64,
-    
-    // Estado que target shard precisa
-    pub entries: Vec<StateEntry>,
-    
-    // Assinado por validador de source shard
-    pub signature: Bls12381G2Signature,
-}
-```
-
-### Fluxo
-
-```
-Shard 0 (source):
-1. Recebe TX: "Transferir 100 de A para B"
-2. Executa: A = 900
-3. Gera StateProvision:
-   â”œâ”€ tx_hash = hash(TX)
-   â”œâ”€ source_shard = 0
-   â”œâ”€ target_shard = 1
-   â”œâ”€ entries = [StateEntry(A, 900)]
-4. Assina com BLS (DOMAIN_STATE_PROVISION)
-5. Envia para Shard 1
-
-Shard 1 (target):
-1. Recebe StateProvision
-2. Valida assinatura (BLS verification)
-3. Armazena: "TX foi commitada em Shard 0"
-4. Aguarda CommitmentProof (agregaÃ§Ã£o)
-```
+## âœ… Checkpoint 2: Protocolo de Consenso
 
-### ğŸ§  ReflexÃ£o
-
-**Pergunta**: Por que StateProvision Ã© assinado?
+VocÃª agora entende:
+- âœ… O fluxo bÃ¡sico do HotStuff-2 (proposta, voto, QC)
+- âœ… A regra de duas cadeias para o commit
+- âœ… O bloqueio de voto para seguranÃ§a
+- âœ… A regra de desbloqueio para liveness
+- âœ… Como as mudanÃ§as de view implÃ­citas funcionam
 
-**Resposta**: Para provar que um validador de Shard 0 realmente viu a transaÃ§Ã£o ser executada. Sem assinatura, alguÃ©m poderia inventar StateProvisions falsas!
+**PrÃ³ximo**: ExecuÃ§Ã£o de TransaÃ§Ãµes e MÃ¡quina de Estados
 
 ---
 
-## 3.3 CommitmentProof (AgregaÃ§Ã£o)
+# ğŸ“š MÃ³dulo 3: ExecuÃ§Ã£o e MÃ¡quina de Estados
 
-### Conceito
+## 3.1 O Problema da ExecuÃ§Ã£o
 
-**CommitmentProof** agrega mÃºltiplas StateProvisions em uma Ãºnica prova.
+Uma vez que um bloco Ã© **commitado**, suas transaÃ§Ãµes precisam ser **executadas** para mudar o estado da aplicaÃ§Ã£o (ex: saldos de contas).
 
-```rust
-// Arquivo: crates/types/src/proofs.rs
+**Desafio**: A execuÃ§Ã£o deve ser **determinÃ­stica**. Todos os validadores devem chegar ao **mesmo estado final** apÃ³s executar as mesmas transaÃ§Ãµes.
 
-pub struct CommitmentProof {
-    pub tx_hash: Hash,
-    pub source_shard: ShardGroupId,
-    
-    // Quem assinou (bitfield)
-    pub signers: SignerBitfield,
-    
-    // Assinatura agregada
-    pub aggregated_signature: Bls12381G2Signature,
-    
-    pub block_height: BlockHeight,
-    pub block_timestamp: u64,
-    
-    // Estado (Ãºnico, compartilhado)
-    pub entries: Arc<Vec<StateEntry>>,
-}
 ```
+Estado Inicial: { "alice": 10, "bob": 5 }
+TransaÃ§Ã£o: { "de": "alice", "para": "bob", "valor": 3 }
 
-### Fluxo
-
-```
-Shard 1 recebe mÃºltiplas StateProvisions:
-â”œâ”€ StateProvision de V0 (assinado)
-â”œâ”€ StateProvision de V1 (assinado)
-â”œâ”€ StateProvision de V2 (assinado)
-â””â”€ StateProvision de V3 (assinado)
-
-AgregaÃ§Ã£o:
-â”œâ”€ Coleta assinaturas: [S0, S1, S2, S3]
-â”œâ”€ Agrega: S_agg = S0 + S1 + S2 + S3
-â”œâ”€ Cria CommitmentProof:
-â”‚  â”œâ”€ aggregated_signature = S_agg
-â”‚  â”œâ”€ signers = [1,1,1,1] (bitfield)
-â”‚  â””â”€ entries = [StateEntry(A, 900)]
-â””â”€ Inclui em bloco
+Validador 1 executa â†’ Estado Final: { "alice": 7, "bob": 8 }
+Validador 2 executa â†’ Estado Final: { "alice": 7, "bob": 8 } âœ…
 ```
 
-### BenefÃ­cio: CompressÃ£o
+### O que Acontece se a ExecuÃ§Ã£o NÃ£o Ã© DeterminÃ­stica?
 
-```
-Sem agregaÃ§Ã£o:
-- 4 StateProvisions Ã— (64 bytes sig + 100 bytes data) = 656 bytes
-
-Com agregaÃ§Ã£o:
-- 1 CommitmentProof = 48 bytes (sig) + 48 bytes (bitfield) + 100 bytes (data) = 196 bytes
-
-Economia: 70%! ğŸ‰
-```
-
-### ğŸ§  ReflexÃ£o
-
-**Pergunta**: CommitmentProof agrega assinaturas de Shard 0. Como Shard 1 valida?
-
-**Resposta**: 
-1. Extrai bitfield (quem assinou)
-2. Coleta chaves pÃºblicas dos assinadores de Shard 0
-3. Verifica assinatura agregada
-4. Se vÃ¡lida â†’ Quorum de Shard 0 viu a transaÃ§Ã£o
+Se V1 e V2 chegam a estados finais diferentes, o **consenso Ã© quebrado**. A `state_root` em seus prÃ³ximos blocos propostos serÃ¡ diferente, e eles nunca mais concordarÃ£o.
 
 ---
 
-## 3.4 Livelock Detection (Ciclos)
-
-### Problema
-
-```
-TX A: Shard 0 â†’ Shard 1
-TX B: Shard 1 â†’ Shard 0
+## 3.2 Jellyfish Merkle Tree (JMT)
 
-Shard 0 aguarda provision de B (que estÃ¡ em Shard 1)
-Shard 1 aguarda provision de A (que estÃ¡ em Shard 0)
-DEADLOCK! âŒ
-```
+O Hyperscale-rs usa uma **Jellyfish Merkle Tree (JMT)** para representar o estado da aplicaÃ§Ã£o. Ã‰ uma Ã¡rvore Merkle esparsa otimizada para inserÃ§Ãµes e atualizaÃ§Ãµes eficientes.
 
-### VisualizaÃ§Ã£o
+### Conceito
 
+- **Chaves**: EndereÃ§os de contas (hashes de 256 bits)
+- **Valores**: Dados da conta (saldo, nonce, etc.)
+- **Caminho**: O caminho da raiz atÃ© uma folha Ã© determinado pelos bits da chave.
+
+```
+                 Root
+                 /   \
+                /     \
+               /       \
+              /         \
+             /           \
+            /             \
+           /               \
+          /                 \
+         /                   \
+        /                     \
+       /                       \
+      /                         \
+     /                           \
+    /                             \
+   /                               \
+  /                                 \
+ /                                   \
+Chave: 0110...1011
+Folha: (Chave, Valor)
 ```
-Shard 0:
-â”œâ”€ TX A: Read(A), Write(B_remote)
-â””â”€ Aguarda provision de B
-
-Shard 1:
-â”œâ”€ TX B: Read(B), Write(A_remote)
-â””â”€ Aguarda provision de A
 
-CICLO: A â†’ B â†’ A
-```
+### BenefÃ­cios
 
-### SoluÃ§Ã£o: Cycle Detection
+- **Raiz de Estado Ãšnica**: A raiz da JMT Ã© um hash que representa de forma Ãºnica todo o estado da aplicaÃ§Ã£o. Qualquer mudanÃ§a no estado resulta em uma nova raiz.
+- **Provas de InclusÃ£o/ExclusÃ£o**: Pode-se provar criptograficamente que uma conta existe (ou nÃ£o existe) no estado.
+- **EficiÃªncia**: Otimizada para o padrÃ£o de acesso de blockchains, onde o estado Ã© grande, mas apenas uma pequena parte Ã© modificada em cada bloco.
 
-```rust
-// Arquivo: crates/execution/src/cycle_detection.rs
-
-pub fn detect_cycle(
-    tx: &Transaction,
-    provisions: &HashMap<Hash, StateProvision>,
-) -> Option<CycleProof> {
-    // Construir grafo de dependÃªncias
-    let mut graph = DependencyGraph::new();
-    
-    for (tx_hash, provision) in provisions {
-        // Se TX A lÃª de Shard 1, e TX B escreve para Shard 0
-        // EntÃ£o hÃ¡ aresta: A â†’ B
-        graph.add_edge(tx_hash, ...);
-    }
-    
-    // Detectar ciclo
-    if let Some(cycle) = graph.find_cycle() {
-        // Determinar winner (por hash)
-        let winner = cycle.iter().min_by_key(|tx| tx.hash());
-        let loser = cycle.iter().max_by_key(|tx| tx.hash());
-        
-        // Criar prova assinada por quorum
-        Some(CycleProof {
-            winner_tx_hash: winner.hash(),
-            loser_tx_hash: loser.hash(),
-            winner_commitment: get_commitment(winner),
-            aggregated_signature: sign_cycle_proof(...),
-        })
-    } else {
-        None
-    }
-}
-```
-
-### Deferral (Adiar TransaÃ§Ã£o)
+### CÃ³digo Real
 
 ```rust
-// Arquivo: crates/types/src/transaction.rs
+// Arquivo: crates/executor/src/state.rs
 
-pub struct TransactionDefer {
-    pub tx_hash: Hash,
-    pub reason: DeferReason,
-    pub proof: CycleProof,
-    pub block_height: BlockHeight,
+// O `State` envolve a JMT
+pub struct State<S: Storage> {
+    tree: JellyfishMerkleTree<S, Blake3Hasher>,
+    version: Version,
 }
 
-pub enum DeferReason {
-    LivelockCycle { winner_tx_hash: Hash },
+impl<S: Storage> State<S> {
+    // Aplica um conjunto de escritas (key-value pairs) ao estado
+    pub fn apply(&mut self, writes: &[(Key, Option<Value>)]) -> Result<Hash> {
+        let (new_root, _tree_update) = self
+            .tree
+            .put_value_set(writes, self.version + 1)?;
+        
+        self.version += 1;
+        Ok(new_root)
+    }
 }
 ```
 
-### Fluxo
-
-```
-1. Detectar ciclo entre TX A e TX B
-2. Determinar winner (TX A) e loser (TX B)
-3. Criar CycleProof (assinado por quorum)
-4. Incluir TransactionDefer em bloco:
-   â”œâ”€ tx_hash = B
-   â”œâ”€ reason = LivelockCycle { winner = A }
-   â””â”€ proof = CycleProof
-5. TX B Ã© adiada (retry com novo hash)
-6. TX A continua normalmente
-```
-
 ### ğŸ§  ReflexÃ£o
 
-**Pergunta**: Por que TX B recebe novo hash quando Ã© adiada?
+**Pergunta**: Como a `state_root` na `BlockHeader` se relaciona com a JMT?
 
-**Resposta**: Para que ela seja tratada como transaÃ§Ã£o diferente! Sem novo hash, ela teria o mesmo hash e seria rejeitada como duplicada.
+**Resposta**: A `state_root` na `BlockHeader` Ã© exatamente a raiz da JMT apÃ³s a execuÃ§Ã£o de todas as transaÃ§Ãµes do bloco. Isso serve como uma prova criptogrÃ¡fica do novo estado do sistema.
 
 ---
 
-## âœ… Checkpoint 3: ExecuÃ§Ã£o DistribuÃ­da
+## 3.3 ExecuÃ§Ã£o de TransaÃ§Ãµes
 
-VocÃª agora entende:
-- âœ… Two-Phase Commit (2PC)
-- âœ… StateProvision (Fase 1)
-- âœ… CommitmentProof (AgregaÃ§Ã£o)
-- âœ… Livelock detection (Ciclos)
-- âœ… Deferral (Adiar transaÃ§Ãµes)
+O `ExecutionState` Ã© o componente responsÃ¡vel por gerenciar a JMT e executar as transaÃ§Ãµes.
 
-**PrÃ³ximo**: PadrÃµes de produÃ§Ã£o
+### Fluxo de ExecuÃ§Ã£o
 
----
-
-# ğŸ“š MÃ³dulo 4: PadrÃµes de ProduÃ§Ã£o
-
-## 4.1 State Machine Pattern
-
-### Conceito
-
-**Toda lÃ³gica Ã© sÃ­ncrona, determinÃ­stica, sem I/O.**
+1.  **Recebe Bloco Commitado**: O `NodeStateMachine` informa ao `ExecutionState` que um novo bloco foi commitado.
+2.  **Executa TransaÃ§Ãµes**: O `ExecutionState` itera sobre as transaÃ§Ãµes do bloco em ordem determinÃ­stica.
+3.  **Calcula Efeitos**: Para cada transaÃ§Ã£o, ele calcula as mudanÃ§as no estado (os `writes`).
+4.  **Aplica ao Estado**: Passa o conjunto de `writes` para o `State::apply`.
+5.  **ObtÃ©m Nova Raiz**: A JMT retorna a nova `state_root`.
+6.  **Verifica ConsistÃªncia**: O `ExecutionState` compara a `state_root` calculada com a `state_root` na `BlockHeader` do bloco. Se forem iguais, a execuÃ§Ã£o foi bem-sucedida.
 
 ```rust
-// Arquivo: crates/bft/src/state.rs
+// LÃ³gica simplificada em crates/executor/src/state.rs
 
-pub struct BftStateMachine {
-    // Estado
-    pub view: u64,
-    pub committed_height: u64,
-    pub voted_heights: HashMap<u64, (Hash, u64)>,
-    pub pending_blocks: HashMap<Hash, PendingBlock>,
+fn execute_block(&mut self, block: &Block) -> Result<()> {
+    // 1. Coleta todas as transaÃ§Ãµes do bloco
+    let transactions = block.all_transactions();
     
-    // ConfiguraÃ§Ã£o
-    pub config: BftConfig,
-}
-
-impl BftStateMachine {
-    pub fn handle(&mut self, event: Event) -> Vec<Action> {
-        match event {
-            Event::ProposalTimer => self.on_proposal_timer(),
-            Event::BlockHeaderReceived { header, ... } => {
-                self.on_block_header(header, ...)
-            }
-            Event::BlockVoteReceived { vote } => {
-                self.on_block_vote(vote)
-            }
-            // ...
-        }
+    // 2. Executa transaÃ§Ãµes e coleta os writes
+    let mut all_writes = Vec::new();
+    for tx in transactions {
+        let writes = self.execute_transaction(tx)?;
+        all_writes.extend(writes);
     }
-}
-```
-
-### BenefÃ­cios
-
-| BenefÃ­cio | DescriÃ§Ã£o |
-|-----------|-----------|
-| **TestÃ¡vel** | Sem dependÃªncias externas (sem network, storage, timers) |
-| **DeterminÃ­stico** | Mesmo estado + evento = mesmas aÃ§Ãµes |
-| **SimulÃ¡vel** | Roda em simulaÃ§Ã£o determinÃ­stica |
-| **DebugÃ¡vel** | Trace completo de eventos |
-| **ReplicÃ¡vel** | Mesma sequÃªncia de eventos = mesmos resultados |
-
-### Exemplo
-
-```rust
-#[test]
-fn test_consensus_advances() {
-    let mut state = BftStateMachine::new(config);
     
-    // Evento 1: Proposal timer
-    let actions = state.handle(Event::ProposalTimer);
-    assert!(actions.contains(&Action::BuildProposal { ... }));
+    // 3. Aplica os writes Ã  JMT
+    let calculated_state_root = self.state.apply(&all_writes)?;
     
-    // Evento 2: Block header received
-    let actions = state.handle(Event::BlockHeaderReceived { ... });
-    assert!(actions.contains(&Action::VerifyQcSignature { ... }));
+    // 4. Verifica se a raiz calculada corresponde Ã  do bloco
+    if calculated_state_root != block.header.state_root {
+        return Err(anyhow!("State root mismatch!"));
+    }
     
-    // Evento 3: QC formed
-    let actions = state.handle(Event::QcFormed { ... });
-    assert_eq!(state.committed_height, 1);
+    Ok(())
 }
 ```
 
 ### ğŸ§  ReflexÃ£o
 
-**Pergunta**: Se state machine Ã© sÃ­ncrono, como ele lida com I/O (network, storage)?
+**Pergunta**: O que acontece se a `state_root` nÃ£o corresponder? Isso pode acontecer em um sistema funcionando corretamente?
 
-**Resposta**: NÃ£o lida! State machine retorna **Actions** que descrevem o que fazer. Um executor externo executa as actions.
+**Resposta**: Em um sistema com validadores honestos, isso **nunca deveria acontecer**. Uma `state_root` que nÃ£o corresponde indica um **bug crÃ­tico** no protocolo de consenso ou na lÃ³gica de execuÃ§Ã£o, ou um **proponente malicioso** que criou um bloco invÃ¡lido. Um validador honesto rejeitaria tal bloco.
 
 ---
 
-## 4.2 Event Aggregator Pattern
-
-### Conceito
-
-Um **Ãºnico task** processa eventos sequencialmente, sem mutex.
-
-```rust
-// Arquivo: crates/production/src/node.rs
-
-async fn run_state_machine(
-    mut state_machine: BftStateMachine,
-    mut event_rx: mpsc::Receiver<Event>,
-) {
-    loop {
-        // Receber evento
-        let event = event_rx.recv().await;
-        
-        // Processar (sÃ­ncrono, sem contention)
-        let actions = state_machine.handle(event);
-        
-        // Executar actions (I/O)
-        for action in actions {
-            execute_action(action).await;
-        }
-    }
-}
-```
-
-### MÃºltiplos Produtores
-
-```
-Network Task:
-â”œâ”€ Recebe mensagens
-â””â”€ Envia para event_rx
-
-Timer Task:
-â”œâ”€ Aguarda timeout
-â””â”€ Envia para event_rx
-
-Storage Task:
-â”œâ”€ LÃª/escreve dados
-â””â”€ Envia para event_rx
-
-         â†“ (mpsc channel)
-
-Event Aggregator:
-â”œâ”€ Processa eventos sequencialmente
-â””â”€ Sem mutex, sem contention
-```
-
-### BenefÃ­cio: Sem Race Conditions
-
-```
-Sem Event Aggregator (com mutex):
-â”œâ”€ Network task tenta adquirir lock
-â”œâ”€ Timer task tenta adquirir lock
-â”œâ”€ Storage task tenta adquirir lock
-â””â”€ Contention, deadlock risk
-
-Com Event Aggregator:
-â”œâ”€ Network task envia evento
-â”œâ”€ Timer task envia evento
-â”œâ”€ Storage task envia evento
-â””â”€ Event aggregator processa sequencialmente
-```
-
-### ğŸ§  ReflexÃ£o
+## âœ… Checkpoint 3: ExecuÃ§Ã£o e Estado
 
-**Pergunta**: Se event aggregator processa sequencialmente, nÃ£o Ã© lento?
+VocÃª agora entende:
+- âœ… A necessidade de execuÃ§Ã£o determinÃ­stica.
+- âœ… Como a Jellyfish Merkle Tree (JMT) Ã© usada para representar o estado.
+- âœ… O fluxo de execuÃ§Ã£o de transaÃ§Ãµes e a verificaÃ§Ã£o da `state_root`.
 
-**Resposta**: NÃ£o! Porque cada evento Ã© processado em microsegundos. Mesmo processando sequencialmente, vocÃª consegue processar milhares de eventos por segundo.
+**PrÃ³ximo**: O ciclo de vida completo de uma transaÃ§Ã£o, do inÃ­cio ao fim.
 
 ---
 
-## 4.3 Thread Pool Specialization
-
-### Conceito
+# ğŸ“š MÃ³dulo 4: O Ciclo de Vida de uma TransaÃ§Ã£o
 
-Diferentes tipos de trabalho â†’ diferentes thread pools.
-
-```rust
-// Arquivo: crates/production/src/thread_pools.rs
+## 4.1 Do Cliente ao Mempool
 
-pub struct ThreadPoolManager {
-    // Crypto pool: BLS verification, signature checks
-    crypto_pool: rayon::ThreadPool,
-    
-    // Execution pool: Radix Engine, merkle computation
-    execution_pool: rayon::ThreadPool,
-    
-    // I/O pool: tokio runtime for network/storage/timers
-    io_runtime: tokio::runtime::Runtime,
-}
-```
-
-### Dispatch
-
-```rust
-fn execute_action(&self, action: Action) {
-    match action {
-        Action::VerifyQcSignature { ... } => {
-            self.crypto_pool.spawn(|| verify_qc_signature(...));
-        }
-        Action::ExecuteTransaction { ... } => {
-            self.execution_pool.spawn(|| execute_transaction(...));
-        }
-        Action::SendMessage { ... } => {
-            self.io_runtime.spawn(async { send_message(...).await });
-        }
-    }
-}
-```
+1.  **CriaÃ§Ã£o**: Um cliente (ex: uma carteira) cria uma transaÃ§Ã£o, a assina com sua chave privada e a envia para um nÃ³ da rede Hyperscale.
+2.  **RecepÃ§Ã£o no NÃ³**: O nÃ³ recebe a transaÃ§Ã£o via RPC.
+3.  **ValidaÃ§Ã£o BÃ¡sica**: O nÃ³ realiza verificaÃ§Ãµes bÃ¡sicas:
+    - A assinatura Ã© vÃ¡lida?
+    - O formato estÃ¡ correto?
+    - O remetente tem saldo suficiente (verificaÃ§Ã£o rÃ¡pida, nÃ£o garantida)?
+4.  **Envio ao Mempool**: Se a validaÃ§Ã£o bÃ¡sica passar, a transaÃ§Ã£o Ã© enviada para o `Mempool`.
 
-### ConfiguraÃ§Ã£o
+---
 
-```rust
-let config = ThreadPoolConfig::auto();
-// Auto-detect cores:
-// - 25% crypto (BLS is CPU-intensive)
-// - 50% execution (Radix Engine is CPU-intensive)
-// - 25% I/O (network/storage is I/O-bound)
-
-// Ou customizar
-let config = ThreadPoolConfig::builder()
-    .crypto_threads(4)
-    .execution_threads(8)
-    .io_threads(2)
-    .pin_cores(true)  // Linux: pin threads to cores
-    .build()?;
-```
+## 4.2 A Vida no Mempool
 
-### ğŸ§  ReflexÃ£o
+O `Mempool` Ã© a "sala de espera" para transaÃ§Ãµes que ainda nÃ£o foram incluÃ­das em um bloco. Sua principal responsabilidade Ã© fornecer um conjunto de transaÃ§Ãµes vÃ¡lidas e prontas para o proponente do prÃ³ximo bloco.
 
-**Pergunta**: Por que separar crypto e execution pools?
+### Estados de uma TransaÃ§Ã£o no Mempool
 
-**Resposta**: Porque eles tÃªm caracterÃ­sticas diferentes:
-- **Crypto**: CPU-intensive, parallelizÃ¡vel (batch verification)
-- **Execution**: CPU-intensive, menos parallelizÃ¡vel (serial execution)
-- Separar permite otimizar cada um
+- **Pending**: A transaÃ§Ã£o acabou de chegar. O Mempool ainda nÃ£o a processou totalmente.
+- **Ready**: A transaÃ§Ã£o foi validada e estÃ¡ pronta para ser incluÃ­da em um bloco.
+- **Committed**: A transaÃ§Ã£o foi incluÃ­da em um bloco que foi **commitado** (mas ainda nÃ£o executado).
+- **Executed**: A transaÃ§Ã£o foi executada com sucesso.
+- **Aborted**: A transaÃ§Ã£o foi abortada (ex: por um conflito que nÃ£o pÃ´de ser resolvido).
+- **Deferred**: A transaÃ§Ã£o perdeu uma disputa de conflito e estÃ¡ temporariamente "adiada" atÃ© que a transaÃ§Ã£o vencedora seja executada.
 
----
+### DetecÃ§Ã£o de Conflitos
 
-## 4.4 Batch Processing
+O Mempool usa um `DependencyGraph` para rastrear quais transaÃ§Ãµes acessam quais partes do estado (quais "nÃ³s" da JMT). Se duas transaÃ§Ãµes tentam modificar o mesmo nÃ³ de estado, hÃ¡ um conflito.
 
-### Batch Verification
+- **ResoluÃ§Ã£o**: O Mempool escolhe um vencedor (geralmente com base na taxa de gÃ¡s ou outra heurÃ­stica) e marca o perdedor como `Deferred`.
+- **Retentativa**: Uma vez que a transaÃ§Ã£o vencedora Ã© executada, a transaÃ§Ã£o `Deferred` Ã© movida de volta para o estado `Pending` para ser reavaliada.
 
 ```rust
-// Arquivo: crates/bft/src/vote_set.rs
-
-pub struct VoteSet {
-    verified_votes: Vec<(usize, BlockVote, u64)>,
-    unverified_votes: Vec<(usize, BlockVote, PublicKey, u64)>,
-    pending_verification: bool,
-}
+// LÃ³gica simplificada em crates/mempool/src/state.rs
 
-impl VoteSet {
-    pub fn try_build_qc(&mut self) -> Option<Action> {
-        // Se temos quorum de votos nÃ£o verificados
-        if self.unverified_power >= quorum_threshold {
-            // Batch verify todos
-            return Some(Action::VerifyAndBuildQuorumCertificate {
-                votes: self.unverified_votes.clone(),
-                public_keys: self.collect_public_keys(),
-            });
+fn process_new_transactions(&mut self) {
+    for tx in self.pending_transactions.drain(..) {
+        // ConstrÃ³i o grafo de dependÃªncias
+        let dependencies = self.dependency_graph.get_dependencies(&tx);
+        
+        if self.has_conflict(dependencies) {
+            // Resolve o conflito, marca um como Deferred
+            self.handle_conflict(tx);
+        } else {
+            // Sem conflitos, move para Ready
+            self.ready_transactions.push(tx);
         }
-        None
     }
 }
 ```
 
-### BenefÃ­cio
-
-```
-Sem batch verification:
-- Voto 1 chega: Verifica (10ms)
-- Voto 2 chega: Verifica (10ms)
-- Voto 3 chega: Verifica (10ms)
-- Total: 30ms
-
-Com batch verification:
-- Voto 1 chega: Buffer
-- Voto 2 chega: Buffer
-- Voto 3 chega: Quorum! Batch verify (15ms)
-- Total: 15ms
-
-Economia: 50%! ğŸ‰
-```
-
-### ğŸ§  ReflexÃ£o
-
-**Pergunta**: Por que batch verification Ã© mais rÃ¡pido?
-
-**Resposta**: Porque BLS12-381 batch verification usa operaÃ§Ãµes parallelizÃ¡veis. Verificar 3 assinaturas em paralelo Ã© mais rÃ¡pido que verificar sequencialmente.
-
 ---
 
-## 4.5 Deterministic Simulation
+## 4.3 Da Proposta Ã  ExecuÃ§Ã£o
 
-### Conceito
-
-Simular consenso em ambiente determinÃ­stico para testes.
+1.  **Proposta de Bloco**: O `BftState` (lÃ­der atual) solicita ao `Mempool` um lote de transaÃ§Ãµes `Ready`.
+2.  **InclusÃ£o no Bloco**: O lÃ­der inclui essas transaÃ§Ãµes em um novo bloco e o transmite.
+3.  **Consenso**: O bloco passa pelo processo de consenso do HotStuff-2 (votaÃ§Ã£o, QC, commit).
+4.  **NotificaÃ§Ã£o de Commit**: O `NodeStateMachine` recebe a notificaÃ§Ã£o de que o bloco foi commitado.
+5.  **NotificaÃ§Ã£o ao Mempool**: O `NodeStateMachine` informa ao `Mempool` que as transaÃ§Ãµes no bloco foram commitadas. O Mempool atualiza o estado dessas transaÃ§Ãµes para `Committed`.
+6.  **ExecuÃ§Ã£o**: O `NodeStateMachine` envia o bloco para o `ExecutionState`.
+7.  **ExecuÃ§Ã£o e AtualizaÃ§Ã£o de Estado**: O `ExecutionState` executa as transaÃ§Ãµes e atualiza a JMT.
+8.  **NotificaÃ§Ã£o de ExecuÃ§Ã£o**: O `ExecutionState` informa ao `NodeStateMachine` o resultado da execuÃ§Ã£o.
+9.  **NotificaÃ§Ã£o Final ao Mempool**: O `NodeStateMachine` informa ao `Mempool` que as transaÃ§Ãµes foram `Executed` (ou `Aborted`). O Mempool pode entÃ£o limpar quaisquer dados relacionados a essas transaÃ§Ãµes finalizadas.
 
-```rust
-// Arquivo: crates/simulation/src/runner.rs
+### Diagrama de SequÃªncia Simplificado
 
-pub struct SimulationRunner {
-    // Event queue ordenado por: (time, priority, node, sequence)
-    event_queue: BTreeMap<EventKey, Event>,
-    
-    // Nodes (in-process)
-    nodes: Vec<BftStateMachine>,
-    
-    // Storage (in-memory)
-    storage: SimStorage,
-    
-    // Network (simulated latency)
-    network: SimulatedNetwork,
-}
-
-impl SimulationRunner {
-    pub fn run_until(&mut self, duration: Duration) {
-        while self.current_time < duration {
-            let event = self.event_queue.pop_first();
-            let actions = self.nodes[event.node].handle(event);
-            
-            for action in actions {
-                self.execute_action(action);
-            }
-        }
-    }
-}
 ```
-
-### Uso
-
-```rust
-#[test]
-fn test_consensus_with_latency() {
-    let config = NetworkConfig {
-        num_shards: 2,
-        validators_per_shard: 4,
-        intra_shard_latency: Duration::from_millis(10),
-        cross_shard_latency: Duration::from_millis(50),
-    };
-    
-    let mut runner = SimulationRunner::new(config, seed=42);
-    runner.initialize_genesis();
-    runner.run_until(Duration::from_secs(10));
-    
-    // Verificar resultados
-    assert_eq!(runner.committed_height(), 100);
-    assert_eq!(runner.view_changes(), 0);
-}
+Cliente -> NÃ³ -> Mempool -> BFT (LÃ­der) -> BFT (Validadores) -> NodeStateMachine -> ExecutionState
+   |        |       | (Ready)      | (Proposta)        | (Votos)           | (Commit)           | (ExecuÃ§Ã£o)
+   |        |       |              |                   |                   |                    |
+   |        |       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€|-------------------|-------------------> Notifica Mempool (Committed)
+   |        |                      |                   |                   |                    |
+   |        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€|-------------------|-------------------|--------------------> Notifica Mempool (Executed)
 ```
 
-### Determinismo
-
-```
-Seed 42:
-â”œâ”€ Run 1: committed_height = 100, view_changes = 0
-â”œâ”€ Run 2: committed_height = 100, view_changes = 0
-â””â”€ Run 3: committed_height = 100, view_changes = 0
-
-Seed 43:
-â”œâ”€ Run 1: committed_height = 98, view_changes = 1
-â”œâ”€ Run 2: committed_height = 98, view_changes = 1
-â””â”€ Run 3: committed_height = 98, view_changes = 1
-```
-
-### ğŸ§  ReflexÃ£o
-
-**Pergunta**: Se simulaÃ§Ã£o Ã© determinÃ­stica, como testa comportamento com falhas aleatÃ³rias?
-
-**Resposta**: Usa seed diferente! Seed controla qual nÃ³ falha, quando falha, etc. Diferentes seeds = diferentes cenÃ¡rios.
-
 ---
 
-## âœ… Checkpoint 4: ProduÃ§Ã£o
+## âœ… Checkpoint 4: Ciclo de Vida Completo
 
-VocÃª agora entende:
-- âœ… State machine pattern
-- âœ… Event aggregator pattern
-- âœ… Thread pool specialization
-- âœ… Batch processing
-- âœ… Deterministic simulation
-
----
-
-# ğŸ¯ ConclusÃ£o: Tudo Junto
+ParabÃ©ns! VocÃª rastreou uma transaÃ§Ã£o desde sua criaÃ§Ã£o atÃ© sua execuÃ§Ã£o final. VocÃª agora tem uma visÃ£o completa de como os principais componentes do Hyperscale-rs trabalham juntos.
 
-## Fluxo Completo (Exemplo PrÃ¡tico)
+### O que vocÃª aprendeu:
+- Como uma transaÃ§Ã£o entra no sistema.
+- O papel do Mempool na validaÃ§Ã£o e resoluÃ§Ã£o de conflitos.
+- Como os diferentes componentes (`Mempool`, `BftState`, `ExecutionState`, `NodeStateMachine`) se comunicam para mover uma transaÃ§Ã£o atravÃ©s do sistema.
 
-```
-1. USUÃRIO submete transaÃ§Ã£o
-   â””â”€ Event: SubmitTransaction
-
-2. MEMPOOL recebe transaÃ§Ã£o
-   â””â”€ Armazena em mempool
-
-3. PROPOSER (V0) timeout
-   â””â”€ Event: ProposalTimer
-   â””â”€ Action: BuildProposal
-
-4. BUILDER computa state_root
-   â””â”€ Executa certificados
-   â””â”€ Computa merkle root
-   â””â”€ Action: BroadcastBlockHeader
-
-5. VALIDADORES (V1, V2, V3) recebem header
-   â””â”€ Event: BlockHeaderReceived
-   â””â”€ Validam header
-   â””â”€ Aguardam dados
-   â””â”€ Action: FetchTransactions
-
-6. DADOS chegam via gossip
-   â””â”€ Bloco completo
-   â””â”€ Action: VerifyQcSignature (async)
-
-7. QC VERIFICADO (callback)
-   â””â”€ Verificam state_root (async)
-   â””â”€ Action: VerifyStateRoot (async)
-
-8. STATE_ROOT VERIFICADO (callback)
-   â””â”€ Criam BlockVote
-   â””â”€ Assinam com BLS
-   â””â”€ Action: SendBlockVote
-
-9. PROPOSER (V0) recebe votos
-   â””â”€ Event: BlockVoteReceived (3x)
-   â””â”€ Agrega assinaturas
-   â””â”€ Action: VerifyAndBuildQuorumCertificate (async, batch)
-
-10. QC FORMADO (callback)
-    â””â”€ Broadcast QC
-    â””â”€ Bloco em height 0 COMMITADO (two-chain rule)
-    â””â”€ Event: QcFormed
-
-11. EXECUTION coordena
-    â””â”€ Executa bloco commitado
-    â””â”€ Gera StateProvisions (cross-shard)
-    â””â”€ Atualiza JMT
-
-12. PRÃ“XIMO ROUND
-    â””â”€ Proposer muda
-    â””â”€ Consenso avanÃ§a
-```
+## ğŸš€ PrÃ³ximos Passos
 
-## Conceitos Aprendidos
-
-| Conceito | Por que Importa |
-|----------|-----------------|
-| **Blake3 Hashing** | Prova integridade de dados |
-| **Merkle Trees** | Prova inclusÃ£o de transaÃ§Ãµes |
-| **BLS12-381** | Assinaturas agregÃ¡veis (compressÃ£o) |
-| **Domain Separation** | Previne replay attacks |
-| **Vote Locking** | Garante seguranÃ§a (safety) |
-| **Unlock Rule** | Garante liveness (consenso avanÃ§a) |
-| **Two-Chain Rule** | Finality em 2 rounds |
-| **State Root Verification** | Valida execuÃ§Ã£o |
-| **CommitmentProof** | Prova cross-shard execution |
-| **Cycle Detection** | Previne deadlock |
-| **State Machine Pattern** | Testabilidade e determinismo |
-| **Event Aggregator** | Sem race conditions |
-| **Thread Pool Specialization** | Performance |
-| **Batch Processing** | CompressÃ£o de I/O |
-| **Deterministic Simulation** | Testes confiÃ¡veis |
-
-## PrÃ³ximos Passos (Opcional)
-
-1. **Ler o cÃ³digo real**: Comece por `crates/types/src/` (tipos)
-2. **Entender BFT**: Leia `crates/bft/src/state.rs` (consenso)
-3. **Estudar Execution**: Leia `crates/execution/src/` (execuÃ§Ã£o)
-4. **Rodar Testes**: `cargo test --all` (validar compreensÃ£o)
-5. **Simular**: Rode `crates/simulation/tests/` (ver em aÃ§Ã£o)
-
-## Recursos Recomendados
-
-- **HotStuff Paper**: https://arxiv.org/abs/1803.05069
-- **BLS12-381**: https://electriccoin.co/blog/bls12-381-zk-proofs/
-- **Merkle Trees**: https://en.wikipedia.org/wiki/Merkle_tree
-- **Two-Phase Commit**: https://en.wikipedia.org/wiki/Two-phase_commit_protocol
-
----
+Com esta base sÃ³lida, vocÃª estÃ¡ pronto para explorar tÃ³picos mais avanÃ§ados no cÃ³digo do Hyperscale-rs:
 
-**ParabÃ©ns! VocÃª agora entende os fundamentos de consenso distribuÃ­do, criptografia e padrÃµes de produÃ§Ã£o atravÃ©s do Hyperscale-RS!** ğŸ‰
+- **ExecuÃ§Ã£o Cross-Shard**: Como as transaÃ§Ãµes que abrangem mÃºltiplos shards sÃ£o coordenadas?
+- **RecuperaÃ§Ã£o de Falhas**: O que acontece quando um nÃ³ reinicia?
+- **OtimizaÃ§Ãµes de Rede**: Como o gossip e a comunicaÃ§Ã£o de rede sÃ£o gerenciados?
 
+Boa exploraÃ§Ã£o!
+'''
